
#Область ОбработчикиСобытийФормы

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	// СтандартныеПодсистемы.ВерсионированиеОбъектов.
	ВерсионированиеОбъектов.ПриСозданииНаСервере(ЭтотОбъект);
	// Конец СтандартныеПодсистемы.ВерсионированиеОбъектов.
	
	// Стандартные действия при создании на сервере.
	бит_РаботаСДиалогамиСервер.ФормаОбъектаПриСозданииНаСервере(Отказ, СтандартнаяОбработка, ЭтотОбъект, Объект);
		
	Если Отказ Тогда
		Возврат;
	КонецЕсли;

	ЗаполнитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);
	
    ОбновитьТаблицуПравил();
    ОбновитьТаблицуИсключений();
    
    УстановитьОтборШаблонаДвижений();
	
	//ОКЕЙ Бублик А.А.(СофтЛаб) Начало 2020-09-02 (#3825)
	ок_УправлениеФормами.ПриСозданииНаСервере(ЭтаФорма, Отказ, СтандартнаяОбработка);
	//ОКЕЙ Бублик А.А.(СофтЛаб) Конец 2020-09-02 (#3825) 
	
КонецПроцедуры // ПриСозданииНаСервере()

&НаКлиенте
Процедура ОбработкаОповещения(ИмяСобытия, Параметр, Источник)
	
	Если ИмяСобытия = "ФормаРедактированияТекста" Тогда
		
		Если ТипЗнч(Параметр) = Тип("Структура") 
			 И Параметр.Свойство("ИмяТабличногоПоля")
			 И Параметр.Свойство("ИмяПоля")
			 И ЗначениеЗаполнено(Параметр.ИмяТабличногоПоля) 
			 И ЗначениеЗаполнено(Параметр.ИмяПоля) Тогда
			
	        ТекущаяСтрока     = Элементы[Параметр.ИмяТабличногоПоля].ТекущиеДанные;
			
			Если НЕ ТекущаяСтрока = Неопределено Тогда
				
				ТекущаяСтрока[Параметр.ИмяПоля] = Параметр.Текст;
				Модифицированность = Истина;
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЕсли; 
	
КонецПроцедуры

&НаСервере
Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
	
	Если НЕ Отказ Тогда
		
		ТекущийОбъект.ЗначенияРеквизитов.Очистить();
		ТекущийОбъект.ИерархияСтрок.Очистить();
		
		// Сохраняем значения реквизитов таблицы правил.
		ЗаполнитьЗначенияРеквизитов(ТекущийОбъект, ТаблицаПравила);
		
		// Сохраняем значения реквизитов таблицы исключений.
		Для каждого СтрокаТаблицы Из ТаблицаИсключения Цикл
		
			ЗаполнитьЗначенияРеквизитовПоСтроке(ТекущийОбъект, СтрокаТаблицы, фКолонкиИсключения, "Исключения");
			
		КонецЦикла; 
		
		ТабПравилаВрем    = РеквизитФормыВЗначение("ТаблицаПравила");
		ТабИсключенияВрем = РеквизитФормыВЗначение("ТаблицаИсключения");
	    НастройкиКолонок  = ПолучитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);
		ТекущийОбъект.КодУсловияТрансляции = ТекущийОбъект.ГенерироватьКод(ТабПравилаВрем, ТабИсключенияВрем, НастройкиКолонок);
		
	КонецЕсли;	
	
КонецПроцедуры

&НаСервере
Процедура ПослеЗаписиНаСервере(ТекущийОбъект, ПараметрыЗаписи)
	
	УстановитьКодТрансляции(Объект.КодУсловияТрансляции, фПоказатьМаркеры);
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовШапкиФормы

&НаКлиенте
Процедура НастройкаПравилТрансляцииПриИзменении(Элемент)
	
	ИзменениеНастройки();
	
КонецПроцедуры

&НаКлиенте
Процедура ГруппаСтраницыПриСменеСтраницы(Элемент, ТекущаяСтраница)
	
	Если ТекущаяСтраница = Элементы.ГруппаКодУсловияТрансляции Тогда
		Если НЕ КодУстановлен Тогда
			 УстановитьКодТрансляции(Объект.КодУсловияТрансляции, фПоказатьМаркеры);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицыФормыТаблицаПравила

&НаКлиенте
Процедура ТаблицаПравилаПередНачаломДобавления(Элемент, Отказ, Копирование, Родитель, Группа)
	
	Если НЕ НастройкаЗаполнена() Тогда
		
		Отказ = Истина;
		
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаПравилаПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если НоваяСтрока Тогда
		
		ТекущаяСтрока = Элементы.ТаблицаПравила.ТекущиеДанные;
		ПриНачалеРедактированияТаблицыПравил(ТекущаяСтрока, фКолонкиПравила, Копирование);
		
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаПравилаПриИзменении(Элемент)
	
	КоличествоПравил = 0;
	ПеренумероватьСтрокиДерева(ТаблицаПравила, КоличествоПравил);
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицыФормыТаблицаИсключения

&НаКлиенте
Процедура ТаблицаИсключенияПередНачаломДобавления(Элемент, Отказ, Копирование, Родитель, Группа)
	
	Если НЕ НастройкаЗаполнена() Тогда
		
		Отказ = Истина;
		
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаИсключенияПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если НоваяСтрока Тогда
		
		ТекущаяСтрока = Элементы.ТаблицаИсключения.ТекущиеДанные;
		ПриНачалеРедактированияТаблицыПравил(ТекущаяСтрока, фКолонкиИсключения, Копирование);
		
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаИсключенияПриИзменении(Элемент)
	
	КоличествоИсключений = 0;
	ПеренумероватьСтрокиТаблицы(ТаблицаИсключения, КоличествоИсключений);
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиКомандФормы

&НаКлиенте
Процедура КомандаИсключенияОбновитьКолонки(Команда)
	
	ИсключенияОбновитьКолонки();
	
КонецПроцедуры

&НаКлиенте
Процедура КомандаПравилаДобавитьСтрокуВерхнегоУровня(Команда)
	
	Если НЕ НастройкаЗаполнена() Тогда
		
		Возврат;
		
	КонецЕсли; 
	
	СтрокаПравила = ТаблицаПравила.ПолучитьЭлементы().Добавить();
	Элементы.ТаблицаПравила.ТекущаяСтрока = СтрокаПравила.ПолучитьИдентификатор();
	ПриНачалеРедактированияТаблицыПравил(СтрокаПравила, фКолонкиПравила, Ложь);
    ТаблицаПравилаПриИзменении(Элементы.ТаблицаПравила);
	
КонецПроцедуры

&НаКлиенте
Процедура КомандаПравилаОбновитьКолонки(Команда)
	
    ПравилаОбновитьКолонки();

	бит_РаботаСДиалогамиКлиент.РазвернутьДеревоПолностью(Элементы.ТаблицаПравила, ТаблицаПравила.ПолучитьЭлементы());
	
КонецПроцедуры

&НаКлиенте
Процедура КомандаУровеньВверх(Команда)
	
	ТекущаяСтрока   = Элементы.ТаблицаПравила.ТекущиеДанные;
	РодительСтроки = ТекущаяСтрока.ПолучитьРодителя();
	Если ТекущаяСтрока <> Неопределено 
		 И РодительСтроки <> Неопределено Тогда
		
		РодительРодителя = РодительСтроки.ПолучитьРодителя();
		
		Если РодительРодителя <> Неопределено  Тогда
			
			ИндексВставки = РодительРодителя.ПолучитьЭлементы().Индекс(РодительСтроки)+1;
			СкопироватьИерархию(РодительРодителя, ТекущаяСтрока, ИндексВставки);
			
		Иначе	
			
			ИндексВставки = ТаблицаПравила.ПолучитьЭлементы().Индекс(РодительСтроки)+1;			
			СкопироватьИерархию(ТаблицаПравила, ТекущаяСтрока, ИндексВставки);
			
		КонецЕсли; 
		
		КоллекцияРодитель = РодительСтроки.ПолучитьЭлементы();
		КоллекцияРодитель.Удалить(КоллекцияРодитель.Индекс(ТекущаяСтрока));
		
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиенте
Процедура КомандаУровеньВниз(Команда)
	
	ТекущаяСтрока   = Элементы.ТаблицаПравила.ТекущиеДанные;
	
	Если ТекущаяСтрока <> Неопределено 
		  Тогда
		  
	    РодительСтроки = ТекущаяСтрока.ПолучитьРодителя();
		Если РодительСтроки = Неопределено Тогда
			РодительСтроки = ТаблицаПравила
		КонецЕсли;	
		
		КоллекцияРодитель = РодительСтроки.ПолучитьЭлементы();
		Если КоллекцияРодитель.Количество()>=2  Тогда
		
			ТекущийИндекс = КоллекцияРодитель.Индекс(ТекущаяСтрока);
			ТекущийИндекс = ТекущийИндекс-1;
			
			Если ТекущийИндекс >= 0 Тогда
			  	
			  СкопироватьИерархию(КоллекцияРодитель[ТекущийИндекс],ТекущаяСтрока);
		      КоллекцияРодитель.Удалить(КоллекцияРодитель.Индекс(ТекущаяСтрока));
			  
			КонецЕсли; 
		
		КонецЕсли; 
		 
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура КомандаГенерироватьКод(Команда)
	
	Если НастройкаЗаполнена() Тогда
		ГенерироватьКод();
		Элементы.ГруппаСтраницы.ТекущаяСтраница = Элементы.ГруппаКодУсловияТрансляции;
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ДобавитьВИсключенияВыделенные(Команда)
	
	ВыделенныеСтроки = Элементы.ТаблицаПравила.ВыделенныеСтроки;
	Если ВыделенныеСтроки.Количество() <> 0 Тогда
		Для каждого СтрокаТаблицы Из ВыделенныеСтроки Цикл
			ЗаполнитьЗначенияСвойств(ТаблицаИсключения.Добавить(), 
				ТаблицаПравила.НайтиПоИдентификатору(СтрокаТаблицы), ЗначимыеПоляИсключений);
		КонецЦикла; 
		
		Модифицированность   = Истина;
		КоличествоИсключений = 0;
		ПеренумероватьСтрокиТаблицы(ТаблицаИсключения, КоличествоИсключений);
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиенте
Процедура ТекстДляКонфигуратора(Команда)
	
	Текст = Новый ТекстовыйДокумент(); 
	Текст.УстановитьТекст(Объект.КодУсловияТрансляции);
	Текст.Показать(СтрШаблон("Исполняемый код (%1)", 
		?(Объект.Ссылка.Пустая(),Нстр("ru = 'Создание'"), Объект.Наименование)));
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ВспомогательныеПроцедурыФункцииИспользуемыеВПрограммноНазначаемыхОбработчиках

// Формирует структуру параметров, необходимую для вызова формы-конструктора произвольного условия.
// 
&НаСервере
Функция ПодготовитьПараметрыКонструктораПроизвольногоУсловия(ИмяТаблицы, ИдСтроки, НомерУсловия)
	
	РезСтруктура = Справочники.бит_ПравилаТрансляции.КонструкторСтруктурыПоляУсловия();								
	ТекущаяСтрока = ЭтотОбъект[ИмяТаблицы].НайтиПоИдентификатору(ИдСтроки);
	
	Если НЕ ТекущаяСтрока = Неопределено Тогда
		
		Если ИмяТаблицы = "ТаблицаИсключения" Тогда
			СтрКолонки = фКолонкиИсключения;
		Иначе
			СтрКолонки = фКолонкиПравила;
		КонецЕсли;
		
		РезСтруктура = Справочники.бит_ПравилаТрансляции.НайтиПоляУсловия(ТекущаяСтрока, СтрКолонки ,НомерУсловия);		
		
	КонецЕсли;	
	
	РезСтруктура.Вставить("УчитыватьКорреспонденцию", Объект.НастройкаПравилТрансляции.УчитыватьКорреспонденцию);
	
	ВидКолонкиРеквизитИсточника = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитИсточника;
	Если РезСтруктура.УчитыватьКорреспонденцию Тогда
		РезСтруктура.Вставить("Счет"   , ПолучитьЗначениеПоИмениРеквизита("СчетДт",ВидКолонкиРеквизитИсточника,ТекущаяСтрока));
		РезСтруктура.Вставить("СчетКор", ПолучитьЗначениеПоИмениРеквизита("СчетКт",ВидКолонкиРеквизитИсточника,ТекущаяСтрока));				
	Иначе
	    РезСтруктура.Вставить("Счет", ПолучитьЗначениеПоИмениРеквизита("Счет",ВидКолонкиРеквизитИсточника,ТекущаяСтрока));
		РезСтруктура.Вставить("СчетКор", Неопределено);
	КонецЕсли;
	
	// Условия для доп. аналитик.
	Если Найти(ТекущаяСтрока["Условие"+НомерУсловия], "#А.")>0 Тогда
	
		ТекстУсловия = ТекущаяСтрока["Условие"+НомерУсловия];
				
		Если СтрНайти(ТекстУсловия, "ЗначениеЗаполнено(") > 0 Тогда
			ТекстУсловия = СтрЗаменить(ТекстУсловия, "ЗначениеЗаполнено(", "");
			ТекстУсловия = Лев(ТекстУсловия, СтрДлина(ТекстУсловия) - 1); // Последняя скобка.
		КонецЕсли; 
		
		Если бит_МеханизмТрансляции.ЭтоДопРеквизит(ТекстУсловия) Тогда
			
			РезСтруктура.Вставить("Аналитика", Неопределено);
			РезСтруктура.Вставить("ЭтоДопЗначениеАналитик", Ложь);
		Иначе	
			
			ИмяАналитики = СтрЗаменить(ТекстУсловия, "#А.", "");
			Аналитика = ПланыВидовХарактеристик.бит_ВидыДополнительныхАналитик.НайтиПоКоду(ИмяАналитики);
			Если ЗначениеЗаполнено(Аналитика) Тогда
				РезСтруктура.Вставить("Аналитика", Аналитика);
				РезСтруктура.Вставить("ЭтоДопЗначениеАналитик", Аналитика.ТипЗначения.СодержитТип(Тип("СправочникСсылка.бит_ДополнительныеЗначенияАналитик")));
			Иначе
				РезСтруктура.Вставить("Аналитика", Неопределено);
				РезСтруктура.Вставить("ЭтоДопЗначениеАналитик", Ложь);
			КонецЕсли; 
		КонецЕсли; 
		
	Иначе
		
		РезСтруктура.Вставить("Аналитика", Неопределено);
		РезСтруктура.Вставить("ЭтоДопЗначениеАналитик", Ложь);
		
	КонецЕсли; 
	
	Возврат РезСтруктура;	
	
КонецФункции	

&НаКлиенте
Процедура УстановитьПоляУсловия(СтрокаУсловия,РезСтруктура, СтрКолонки, НомерУсловия)
	
	Для каждого КлючИЗначение Из РезСтруктура Цикл
		ИмяКолонки = КлючИЗначение.Ключ+НомерУсловия;
		Если СтрКолонки.Свойство(ИмяКолонки) Тогда
			
			СтрокаУсловия[ИмяКолонки] = РезСтруктура[КлючИЗначение.Ключ] ;
			
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры

&НаКлиенте
Процедура УстановитьПараметрыВыбораВидаСравнения(ПолеФормы, ОписаниеТипов)
	
	НовыеПараметры = Новый Массив();
	НовыеПараметры.Добавить(Новый ПараметрВыбора("ОписаниеТипов", ОписаниеТипов));
	
	НовыеПараметры = Новый ФиксированныйМассив(НовыеПараметры);
	ПолеФормы.ПараметрыВыбора = НовыеПараметры;
	
КонецПроцедуры

&НаСервере
Функция ПолучитьЗначениеПоИмениРеквизита(ИмяРеквизита,ВидКолонки,СтрокаПравил)

	РезЗначение = Неопределено;
	
	СтрОтбор = Новый Структура;
	СтрОтбор.Вставить("ИмяРеквизита",ИмяРеквизита);
	СтрОтбор.Вставить("ВидКолонки"  ,ВидКолонки);
	
	НастройкиКолонок  = ПолучитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);
	МассивСтрок = НастройкиКолонок.НайтиСтроки(СтрОтбор);
	Если МассивСтрок.Количество()>0 Тогда
		
		Если фКолонкиПравила.Свойство(МассивСтрок[0].ИмяКолонки) Тогда
			РезЗначение = СтрокаПравил[МассивСтрок[0].ИмяКолонки];
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат РезЗначение;	  
		  
КонецФункции // НайтиЗначениеПоИмениРеквизита()

&НаСервере
Функция УстановитьЗначениеПоИмениРеквизита(ИмяРеквизита,ВидКолонки,СтрокаПравил,ЗначениеДляУстановки)

	ЗначениеУстановлено = Ложь;
	
	СтрОтбор = Новый Структура;
	СтрОтбор.Вставить("ИмяРеквизита",ИмяРеквизита);
	СтрОтбор.Вставить("ВидКолонки"  ,ВидКолонки);
	
	НастройкиКолонок  = ПолучитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);
	МассивСтрок = НастройкиКолонок.НайтиСтроки(СтрОтбор);
	Если МассивСтрок.Количество()>0 Тогда
		
		Если фКолонкиПравила.Свойство(МассивСтрок[0].ИмяКолонки) Тогда
			СтрокаПравил[МассивСтрок[0].ИмяКолонки] = ЗначениеДляУстановки;
			ЗначениеУстановлено = Истина;
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат ЗначениеУстановлено;	  
		  
КонецФункции // УстановитьЗначениеПоИмениРеквизита()

&НаСервере
Функция СформироватьСписокИменСубконто(ИдСтроки, ИмяКолонки)
	
	СписокВыбора = Новый СписокЗначений;
	ТекущаяСтрока  = ТаблицаПравила.НайтиПоИдентификатору(ИдСтроки);
	
	Если НЕ ТекущаяСтрока = Неопределено 
		 И Объект.Приемник.ВидОбъекта = Перечисления.бит_ВидыОбъектовСистемы.РегистрБухгалтерии Тогда
		 
		 Если НЕ Объект.НастройкаПравилТрансляции.УчитыватьКорреспонденцию Тогда
			 ИмяСчета = "Счет";
		 Иначе	
			 ИмяСчета = "Счет"+Лев(Прав(ИмяКолонки,3),2);
		 КонецЕсли;  
		
		 СчетПриемник 		= ПолучитьЗначениеПоИмениРеквизита(ИмяСчета,Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника,ТекущаяСтрока);
		 МетаданныеРегистра = Метаданные.РегистрыБухгалтерии[Объект.Приемник.ИмяОбъекта];
		 ИмяПВХ 			= МетаданныеРегистра.ПланСчетов.ВидыСубконто.Имя;
		 
		 Если ЗначениеЗаполнено(СчетПриемник) Тогда
			 ИмяТаблицы = Метаданные.НайтиПоТипу(ТипЗнч(СчетПриемник)).ПолноеИмя();
			 
			 ТекстЗапроса =
			 "ВЫБРАТЬ
			 |	Таблица.ВидСубконто КАК ВидСубконто
			 |ИЗ
			 |	#Таблица.ВидыСубконто КАК Таблица
			 |ГДЕ
			 |	Таблица.Ссылка = &Ссылка";
			 ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#Таблица", ИмяТаблицы);
			 Запрос = Новый Запрос;
			 Запрос.Текст = ТекстЗапроса;
			 Запрос.УстановитьПараметр("Ссылка", СчетПриемник);
			 
			 ВыборкаПВХ = Запрос.Выполнить().Выбрать();
			 
			 Пока ВыборкаПВХ.Следующий() Цикл
				 ИмяСубконто = бит_МеханизмТрансляции.ПолучитьИмяСубконто(ИмяПВХ, ВыборкаПВХ.ВидСубконто);
				 СписокВыбора.Добавить(ИмяСубконто);
			 КонецЦикла;
		 КонецЕсли; 
	КонецЕсли;
	
	Возврат СписокВыбора;
	
КонецФункции	

// Функция формирует массив типов, исходя из типов субконто, доступных для данного счета.
// 
// Параметры:
// 	Счет - ПланСчетовСсылка
// 
// Возвращаемое значение:
// 	МассивТипов - Массив
// 
&НаСервере
Функция СформироватьМассивТиповПоСубконтоСчета(Счет)

	МассивТипов = Новый Массив;
    
    СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
    Для Сч = 1 По СвСч.КоличествоСубконто Цикл
        
        ТекТипы = СвСч["ВидСубконто" + Сч + "ТипЗначения"].Типы();
        
        Для каждого ТекТип Из ТекТипы Цикл			
			МассивТипов.Добавить(ТекТип);			
		КонецЦикла;
    
    КонецЦикла;
	
    Возврат МассивТипов;
	
КонецФункции // СформироватьМассивТиповПоСубконтоСчета()

&НаСервере
Процедура СчетПриИзменении(ИмяТаблицы, Счет, ИдСтроки, ИмяКолонки, ВидКолонки)
	
	ТекущаяСтрока = ЭтотОбъект[ИмяТаблицы].НайтиПоИдентификатору(ИдСтроки);
	
	Если НЕ ЗначениеЗаполнено(Счет) ИЛИ ТекущаяСтрока  = Неопределено 
		ИЛИ НЕ ЗначениеЗаполнено(ИмяКолонки)
		ИЛИ Объект.Приемник.ВидОбъекта <> Перечисления.бит_ВидыОбъектовСистемы.РегистрБухгалтерии Тогда
		
		Возврат;
	КонецЕсли; 
	
	Если ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника 
		 И НЕ бит_РаботаСМетаданными.ЕстьРегистрБухгалтерии(Объект.Приемник.ИмяОбъекта) Тогда
	
		 Возврат;
	 КонецЕсли; 
	 
	Если ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитИсточника
		 И НЕ бит_РаботаСМетаданными.ЕстьРегистрБухгалтерии(Объект.Источник.ИмяОбъекта) Тогда
	
		 Возврат;
	КонецЕсли; 
	
	МассивТипов   = СформироватьМассивТиповПоСубконтоСчета(Счет);
	ОписаниеОбщее = Новый ОписаниеТипов(МассивТипов);
	
	Если ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника Тогда
		МетаданныеРегистра = Метаданные.РегистрыБухгалтерии[Объект.Приемник.ИмяОбъекта];
	Иначе
		МетаданныеРегистра = Метаданные.РегистрыБухгалтерии[Объект.Источник.ИмяОбъекта];
	КонецЕсли; 
	
	Если НЕ Объект.НастройкаПравилТрансляции.УчитыватьКорреспонденцию Тогда
		Имя_Субконто    = "Субконто";
		Имя_ВидСубконто = "ИмяВидаСубконто";
	Иначе	
		Имя_Субконто    = "Субконто"+Прав(ИмяКолонки,2);
		Имя_ВидСубконто = "ИмяВидаСубконто"+Прав(ИмяКолонки,2);
	КонецЕсли;  
	
	КоличествоСубконто = МетаданныеРегистра.ПланСчетов.МаксКоличествоСубконто;
	
	Для НомерСубконто = 1 По КоличествоСубконто Цикл
		
		Если ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника Тогда
			ИмяВидаСубконто = ПолучитьЗначениеПоИмениРеквизита(Имя_ВидСубконто+НомерСубконто,ВидКолонки,ТекущаяСтрока);	
		Иначе	
			ИмяВидаСубконто = "";
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(ИмяВидаСубконто) Тогда
			// Если установлено имя субконто - проверим доступно ли данный вид субконто для нового счета.
			ВидыСубконто = ПланыВидовХарактеристик[МетаданныеРегистра.ПланСчетов.ВидыСубконто.Имя];
			Если НЕ бит_МеханизмТрансляции.ЕстьСубконтоНаСчете(Счет,ИмяВидаСубконто,ВидыСубконто) Тогда
				УстановитьЗначениеПоИмениРеквизита(Имя_ВидСубконто+НомерСубконто,ВидКолонки,ТекущаяСтрока,"");
				УстановитьЗначениеПоИмениРеквизита(Имя_Субконто+НомерСубконто,ВидКолонки,ТекущаяСтрока,НЕОПРЕДЕЛЕНО);
			КонецЕсли; 
		Иначе
			
			// Если установлено значение без указания имени - проверим соответствует ли тип значения, 
			// типам субконто доступным для данного счета  .
			ЗначениеСубконто = ПолучитьЗначениеПоИмениРеквизита(Имя_Субконто + НомерСубконто, ВидКолонки, ТекущаяСтрока);	
			
			Если НЕ ЗначениеЗаполнено(ЗначениеСубконто) ИЛИ 
				НЕ ОписаниеОбщее.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда
				
				СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
				Если СвСч.КоличествоСубконто >= НомерСубконто Тогда
					ЗначениеПоУмолчанию = СвСч["ВидСубконто" + НомерСубконто + "ТипЗначения"].ПривестиЗначение();
					УстановитьЗначениеПоИмениРеквизита(Имя_Субконто+НомерСубконто, ВидКолонки, ТекущаяСтрока, ЗначениеПоУмолчанию);
				Иначе	
					УстановитьЗначениеПоИмениРеквизита(Имя_Субконто+НомерСубконто, ВидКолонки, ТекущаяСтрока, Неопределено);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; // Заполнено ИмяВидаСубконто													 
	КонецЦикла;  // По количество субконто
	
КонецПроцедуры

// Процедура обрабатывает начало выбора субконто.
// 
// Параметры:
//  ИмяТаблицы            - Строка
// 	ИдСтроки        	  - Число
// 	ИмяКолонки         	  - Строка
// 	ВидКолонки         	  - ПеречислениеСсылка.бит_ВидыКолонокПравилТрансляции
//  ДобавлятьСтроковойТип - Булево - Признак того, что перечень допустимых типов необходимо дополнять строковым типом.
// 
&НаСервере
Функция СубконтоНачалоВыбора(ИмяТаблицы, ИдСтроки, ИмяКолонки, ВидКолонки, ДобавлятьСтроковойТип = Ложь)
	
	РезСтр = Новый Структура("ВыбиратьТип, ОграничениеТипа", Истина, Новый ОписаниеТипов());
	ТекущаяСтрока = ЭтотОбъект[ИмяТаблицы].НайтиПоИдентификатору(ИдСтроки);
	
	Если ТекущаяСтрока = НЕОПРЕДЕЛЕНО ИЛИ НЕ ЗначениеЗаполнено(ИмяКолонки) Тогда
		Возврат РезСтр;
	КонецЕсли;	
	
	Если НЕ Объект.НастройкаПравилТрансляции.УчитыватьКорреспонденцию Тогда
		Имя_Счет        = "Счет";
		Имя_ВидСубконто = "ИмяВидаСубконто";
	Иначе	
		Имя_Счет        = "Счет"+Лев(Прав(ИмяКолонки,3),2);
		Имя_ВидСубконто = "ИмяВидаСубконто"+Лев(Прав(ИмяКолонки,3),2);
	КонецЕсли;  
	
	Счет = ПолучитьЗначениеПоИмениРеквизита(Имя_Счет, ВидКолонки, ТекущаяСтрока);	  
	
	НомерСубконто = Прав(ИмяКолонки,1);
	ИмяВидаСубконто = "";// ++ NB 
	//Если ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника Тогда
	//	ИмяВидаСубконто = ПолучитьЗначениеПоИмениРеквизита(Имя_ВидСубконто+НомерСубконто, ВидКолонки, ТекущаяСтрока);	
	//Иначе	
	//	ИмяВидаСубконто = "";
	//КонецЕсли; 
	
	Если ЗначениеЗаполнено(ИмяВидаСубконто) Тогда
		
		Если ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника Тогда
			МетаданныеРегистра = Метаданные.РегистрыБухгалтерии[Объект.Приемник.ИмяОбъекта];
		Иначе
			МетаданныеРегистра = Метаданные.РегистрыБухгалтерии[Объект.Источник.ИмяОбъекта];		
		КонецЕсли;	
		
		ИмяПВХ 		= МетаданныеРегистра.ПланСчетов.ВидыСубконто.Имя;
		ВидСубконто = бит_МеханизмТрансляции.НайтиВидСубконто(ИмяПВХ,ИмяВидаСубконто);
		
		Если ЗначениеЗаполнено(ВидСубконто) Тогда
			
			ЗначениеПоУмолчанию = ВидСубконто.ТипЗначения.ПривестиЗначение();
			РезСтр.ВыбиратьТип     = Ложь;
			РезСтр.ОграничениеТипа = ВидСубконто.ТипЗначения;
			
			Если ТипЗнч(ЗначениеПоУмолчанию) <> ТипЗнч(ТекущаяСтрока[ИмяКолонки]) Тогда
				ТекущаяСтрока[ИмяКолонки] =  ЗначениеПоУмолчанию;
			КонецЕсли; 
		КонецЕсли; 
		
	ИначеЕсли ЗначениеЗаполнено(Счет) Тогда
		
		МассивТипов = СформироватьМассивТиповПоСубконтоСчета(Счет);
		Если ДобавлятьСтроковойТип Тогда
			МассивТипов.Добавить(Тип("Строка"));
		КонецЕсли; 
		
		ТекОписание = Новый ОписаниеТипов(МассивТипов);
		
		Если МассивТипов.Количество()>1 Тогда
			РезСтр.ВыбиратьТип     = Истина;
			РезСтр.ОграничениеТипа = ТекОписание;
		Иначе	
			ТекущаяСтрока[ИмяКолонки] = ТекОписание.ПривестиЗначение(ТекущаяСтрока[ИмяКолонки]);
			РезСтр.ВыбиратьТип     = Ложь;
			РезСтр.ОграничениеТипа = ТекОписание;			
		КонецЕсли; 
	Иначе
		// По умолчанию выбираем тип, ограничений нет.
	КонецЕсли; 
	
	Возврат РезСтр;

КонецФункции // СубконтоНачалоВыбора()

// Процедура открывает общую форму бит_КонструкторПроизвольногоУсловия в режиме выбора значения. 
// 
// Параметры:
//  ТекущаяСтрока - Строка.
//  ИмяКолонки - Строка.
//  ОграничениеТипа - ОписаниеТипов.
// 
&НаКлиенте
Процедура ОткрытьФормуВыбораЗначения(ТекущаяСтрока, ИмяКолонки, ОграничениеТипа)
	
	Если ТекущаяСтрока <> Неопределено И ЗначениеЗаполнено(ИмяКолонки) Тогда
		
		НомерУсловия = Прав(ИмяКолонки,1);
		ПараметрыФормы = Новый Структура;
		ПараметрыФормы.Вставить("Режим",		   "ПравилаТрансляции");
		ПараметрыФормы.Вставить("ОбъектСистемы",   Объект.Источник);
		ПараметрыФормы.Вставить("Приемник", 	   Объект.Приемник);
		ПараметрыФормы.Вставить("ВыборВыражения",  Истина);
		ПараметрыФормы.Вставить("ЗначениеФильтра", ТекущаяСтрока[ИмяКолонки]);
		ПараметрыФормы.Вставить("ТипЗначения", 	   ОграничениеТипа);
		
		ДополнительныеДанные = Новый Структура;
		ДополнительныеДанные.Вставить("ТекущаяСтрока", ТекущаяСтрока);
		ДополнительныеДанные.Вставить("ИмяКолонки",ИмяКолонки);
		Оповещение = Новый ОписаниеОповещения("ОткрытиеФормаВыбораПоляЗавершение", ЭтотОбъект, ДополнительныеДанные);
		РежимОкна  = РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс;		
		ОткрытьФорму("ОбщаяФорма.бит_КонструкторПроизвольногоУсловия", ПараметрыФормы, ЭтотОбъект,,,,Оповещение,РежимОкна);
		
	КонецЕсли; 
	
КонецПроцедуры

// Обработчик завершения открытия формы.
//  См. Синтакс-помощник: ОткрытьФорму().
// 
&НаКлиенте 
Процедура ОткрытиеФормаВыбораПоляЗавершение(РезВыбора, ДополнительныеДанные) Экспорт
	
	Если РезВыбора <> Неопределено Тогда
		Если ЗначениеЗаполнено(РезВыбора.Значение) Тогда
			ДополнительныеДанные.ТекущаяСтрока[ДополнительныеДанные.ИмяКолонки] = РезВыбора.Значение;
		КонецЕсли; 
		Модифицированность = Истина;
	КонецЕсли; 
	
КонецПроцедуры	// ОткрытиеФормаВыбораПоляЗавершение

#КонецОбласти

#Область ОбработчикиСобытийНазначаемыеПрограммно

// Подключаемый обработчик событий. 
// Подробности см. ОМ.бит_МеханизмТрансляции.ДобавитьДинамическиеКолонкиТаблицыТрансляции.
// 
&НаКлиенте
Процедура Подключаемый_ПроизвольныйКодНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ИмяТабличногоПоля = Лев(Элемент.Имя,Найти(Элемент.Имя,"_")-1);
	ТекущаяСтрока     = Элементы[ИмяТабличногоПоля].ТекущиеДанные;
	
	ПараметрыФормы   = Новый Структура;										 
	ПараметрыФормы.Вставить("Текст", 			 ТекущаяСтрока.ПроизвольныйКод);
	ПараметрыФормы.Вставить("Заголовок", 		 "Произвольный код");
	ПараметрыФормы.Вставить("ИмяТабличногоПоля", ИмяТабличногоПоля);
	ПараметрыФормы.Вставить("ИмяПоля",			 "ПроизвольныйКод");
	
	ОткрытьФорму("ОбщаяФорма.бит_ФормаРедактированияТекста", ПараметрыФормы, ЭтотОбъект);
	
	
КонецПроцедуры // ПроизвольныйКодНачалоВыбора()

// Подключаемый обработчик событий. 
// Подробности см. ОМ.бит_МеханизмТрансляции.ДобавитьДинамическиеКолонкиТаблицыТрансляции.
// 
&НаКлиенте
Процедура Подключаемый_ПроизвольноеУсловиеНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ИмяТабличногоПоля = Лев(Элемент.Имя,Найти(Элемент.Имя,"_")-1);
	ТекущаяСтрока     = Элементы[ИмяТабличногоПоля].ТекущиеДанные;
	
	ПараметрыФормы   = Новый Структура;										 
	ПараметрыФормы.Вставить("Текст", 			 ТекущаяСтрока.ПроизвольноеУсловие);
	ПараметрыФормы.Вставить("Заголовок", 		 "Произвольное условие");
	ПараметрыФормы.Вставить("ИмяТабличногоПоля", ИмяТабличногоПоля);
	ПараметрыФормы.Вставить("ИмяПоля",			 "ПроизвольноеУсловие");
	
	ОткрытьФорму("ОбщаяФорма.бит_ФормаРедактированияТекста", ПараметрыФормы, ЭтотОбъект);
	
КонецПроцедуры // ПроизвольноеУсловиеНачалоВыбора()

// Подключаемый обработчик событий. 
// Подробности см. ОМ.бит_МеханизмТрансляции.ДобавитьДинамическиеКолонкиТаблицыТрансляции.
// 
&НаКлиенте
Процедура Подключаемый_УсловиеНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	
	Элемент.ВыбиратьТип  = Ложь;
	СтандартнаяОбработка = Ложь;
	
	ИмяТабличногоПоля = Лев(Элемент.Имя,Найти(Элемент.Имя,"_")-1);
	ТекущаяСтрока     = Элементы[ИмяТабличногоПоля].ТекущиеДанные;
	ИмяКолонки = СтрЗаменить(Элемент.Имя, ИмяТабличногоПоля+"_", "");		 
	
	Если ТекущаяСтрока <> Неопределено И ЗначениеЗаполнено(ИмяКолонки) Тогда
		
		НомерУсловия = Прав(ИмяКолонки,1);
		РезСтруктура = ПодготовитьПараметрыКонструктораПроизвольногоУсловия(ИмяТабличногоПоля, 
							ТекущаяСтрока.ПолучитьИдентификатор(), НомерУсловия);
		ПараметрыФормы = Новый Структура;
		ПараметрыФормы.Вставить("Режим"          , "ПравилаТрансляции");
		ПараметрыФормы.Вставить("ОбъектСистемы"  , Объект.Источник);
		ПараметрыФормы.Вставить("Приемник"       , Объект.Приемник);
		ПараметрыФормы.Вставить("ВидСравнения"   , РезСтруктура.ВидСравнения);
		ПараметрыФормы.Вставить("ЗначениеФильтра", РезСтруктура.Значение);
		ПараметрыФормы.Вставить("ТекущееЗначениеФильтра"  , РезСтруктура.Значение);
		ПараметрыФормы.Вставить("ОбъединениеСПоследующим" , РезСтруктура.ОбъединениеСПоследующим);
		ПараметрыФормы.Вставить("Условие", 					РезСтруктура.Условие);
		ПараметрыФормы.Вставить("УчитыватьКорреспонденцию", РезСтруктура.УчитыватьКорреспонденцию);
		ПараметрыФормы.Вставить("Счет"                    , РезСтруктура.Счет);
		ПараметрыФормы.Вставить("СчетКор"                 , РезСтруктура.СчетКор);

		ДополнительныеДанные = Новый Структура;
		ДополнительныеДанные.Вставить("ИмяТабличногоПоля",ИмяТабличногоПоля);
		ДополнительныеДанные.Вставить("ТекущаяСтрока", ТекущаяСтрока);
		ДополнительныеДанные.Вставить("НомерУсловия",НомерУсловия);
		Оповещение = Новый ОписаниеОповещения("ОткрытиеКонструкторЗавершение", ЭтотОбъект, ДополнительныеДанные);
		РежимОкна  = РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс;		
		
		ОткрытьФорму("ОбщаяФорма.бит_КонструкторПроизвольногоУсловия", ПараметрыФормы, ЭтотОбъект,,,,Оповещение,РежимОкна);
		
	КонецЕсли; 
	
КонецПроцедуры // УсловиеНачалоВыбора()

// Процедура обработчик оповещения "ОткрытиеКонструкторЗавершение".
// 
// Параметры:
// РезВыбора - Произвольный
// ДополнительныеДанные - Структура.
// 
&НаКлиенте 
Процедура ОткрытиеКонструкторЗавершение(РезВыбора, ДополнительныеДанные) Экспорт
	
	Если РезВыбора <> Неопределено Тогда
		
		Если ДополнительныеДанные.ИмяТабличногоПоля = "ТаблицаИсключения" Тогда
			СтрКолонки = фКолонкиИсключения;
		Иначе
			СтрКолонки = фКолонкиПравила;
		КонецЕсли;
		
		УстановитьПоляУсловия(ДополнительныеДанные.ТекущаяСтрока, РезВыбора, СтрКолонки, ДополнительныеДанные.НомерУсловия);
		Модифицированность = Истина;
		
	КонецЕсли; 
	
КонецПроцедуры	// ОткрытиеКонструкторЗавершение

// Подключаемый обработчик событий. 
// Подробности см. ОМ.бит_МеханизмТрансляции.ДобавитьДинамическиеКолонкиТаблицыТрансляции.
// 
&НаКлиенте
Процедура Подключаемый_ЗначениеНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	
	ИмяТабличногоПоля = Лев(Элемент.Имя,Найти(Элемент.Имя,"_")-1);
	ТекущаяСтрока     = Элементы[ИмяТабличногоПоля].ТекущиеДанные;
	ИмяКолонки = СтрЗаменить(Элемент.Имя, ИмяТабличногоПоля+"_", "");		 
	
	Если ТекущаяСтрока <> Неопределено И ЗначениеЗаполнено(ИмяКолонки) Тогда
		
		НомерУсловия = Прав(ИмяКолонки,1); 
		РезСтруктура = ПодготовитьПараметрыКонструктораПроизвольногоУсловия(ИмяТабличногоПоля, ТекущаяСтрока.ПолучитьИдентификатор(), НомерУсловия);			
		Если ТипЗнч(РезСтруктура.Значение) = Тип("СправочникСсылка.бит_ОбъектыСистемы") Тогда
			
			Элемент.ВыбиратьТип  = Ложь;
			СтандартнаяОбработка = Ложь;
			
			ДоступныеВидыОбъектов = Новый СписокЗначений;
			ДоступныеВидыОбъектов.Добавить(ПредопределенноеЗначение("Перечисление.бит_ВидыОбъектовСистемы.Документ"));
			
			ПараметрыФормы = Новый Структура;
			ПараметрыФормы.Вставить("ВидыОбъектов"           ,ДоступныеВидыОбъектов);
			ПараметрыФормы.Вставить("ТекущийОбъектСистемы"   ,РезСтруктура.Значение);
			
			ОткрытьФорму("ОбщаяФорма.бит_ФормаВыбораОбъектовСистемыУправляемая", ПараметрыФормы, Элемент);
			
		ИначеЕсли НЕ РезСтруктура.Значение = Неопределено Тогда
			
			Элемент.ВыбиратьТип = Ложь;
			
		Иначе	
			
			Элемент.ВыбиратьТип = Истина;
			
		КонецЕсли; 
		
		// Установка отбора для доп. значений аналитик.
		Если РезСтруктура.ЭтоДопЗначениеАналитик Тогда
			
			СтрОтбор = Новый Структура("Владелец", РезСтруктура.Аналитика);
			бит_ОбщегоНазначенияКлиентСервер.УстановитьПараметрыВыбораЭлемента(Элемент, СтрОтбор);
			
		Иначе	 
			
			Если РезСтруктура.ВидСравнения = ПредопределенноеЗначение("Перечисление.бит_ВидыСравненияТрансляции.ВГруппе") Тогда
				НовыеПараметрыВыбора = Новый Массив; 
				НовыеПараметрыВыбора.Добавить(Новый ПараметрВыбора("Отбор.ЭтоГруппа", Истина));
				НовыеПараметрыВыбора.Добавить(Новый ПараметрВыбора("ВыборГруппИЭлементов", ИспользованиеГруппИЭлементов.Группы));
				Элемент.ПараметрыВыбора = Новый ФиксированныйМассив(НовыеПараметрыВыбора);			
			Иначе	
				Элемент.ПараметрыВыбора = Новый ФиксированныйМассив(Новый Массив);			
			КонецЕсли; 			
			
		КонецЕсли; 
		
	КонецЕсли; 
	
КонецПроцедуры // УсловиеНачалоВыбора()

// Процедура обрабатывает АвтоПодбор поля "ИмяВидаСубконто".
// 
&НаКлиенте
Процедура Подключаемый_ИмяВидаСубконтоАвтоПодбор(Элемент, Текст, ДанныеВыбора, Параметры, Ожидание, СтандартнаяОбработка)

	Если Ожидание = 0 Тогда
		
        СтандартнаяОбработка = Ложь;		
		
		ТекущаяСтрока = Элементы.ТаблицаПравила.ТекущиеДанные;
		ИмяКолонки = СтрЗаменить(Элемент.Имя, "ТаблицаПравила_", "");		 
		ДанныеВыбора = СформироватьСписокИменСубконто(ТекущаяСтрока.ПолучитьИдентификатор(), ИмяКолонки);
		
	КонецЕсли; 
	
КонецПроцедуры // ИмяВидаСубконтоНачалоВыбора()

// Подключаемый обработчик событий. 
// Подробности см. ОМ.бит_МеханизмТрансляции.ДобавитьДинамическиеКолонкиТаблицыТрансляции.
// 
&НаКлиенте
Процедура Подключаемый_СчетПриемникПриИзменении(Элемент)

	ТекущаяСтрока = Элементы.ТаблицаПравила.ТекущиеДанные;
    ИмяКолонки = СтрЗаменить(Элемент.Имя, "ТаблицаПравила_", "");		 
	
	СчетПриИзменении("ТаблицаПравила", ТекущаяСтрока[ИмяКолонки], ТекущаяСтрока.ПолучитьИдентификатор(),
		ИмяКолонки, ПредопределенноеЗначение("Перечисление.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника"));

КонецПроцедуры // СчетИсточникПриИзменении()

// Подключаемый обработчик событий. 
// Подробности см. ОМ.бит_МеханизмТрансляции.ДобавитьДинамическиеКолонкиТаблицыТрансляции.
// 
&НаКлиенте
Процедура Подключаемый_СчетИсточникПриИзменении(Элемент)
	
	ИмяТабличногоПоля = Лев(Элемент.Имя,Найти(Элемент.Имя,"_")-1);
	ТекущаяСтрока     = Элементы[ИмяТабличногоПоля].ТекущиеДанные;
	ИмяКолонки        = СтрЗаменить(Элемент.Имя, ИмяТабличногоПоля+"_", "");		 
	
	СчетПриИзменении(ИмяТабличногоПоля
	                  , ТекущаяСтрока[ИмяКолонки]
					  , ТекущаяСтрока.ПолучитьИдентификатор()
					  , ИмяКолонки
					  , ПредопределенноеЗначение("Перечисление.бит_ВидыКолонокПравилТрансляции.РеквизитИсточника"));
	
КонецПроцедуры // СчетИсточникПриИзменении()

// Подключаемый обработчик событий. 
// Подробности см. ОМ.бит_МеханизмТрансляции.ДобавитьДинамическиеКолонкиТаблицыТрансляции.
// 
&НаКлиенте
Процедура Подключаемый_СубконтоИсточникНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)

	ИмяТабличногоПоля = Лев(Элемент.Имя,Найти(Элемент.Имя,"_")-1);
	ТекущаяСтрока     = Элементы[ИмяТабличногоПоля].ТекущиеДанные;
	ИмяКолонки        = СтрЗаменить(Элемент.Имя, ИмяТабличногоПоля+"_", "");		 		
		
	РезСтр = СубконтоНачалоВыбора(ИмяТабличногоПоля, ТекущаяСтрока.ПолучитьИдентификатор(), ИмяКолонки, 
				ПредопределенноеЗначение("Перечисление.бит_ВидыКолонокПравилТрансляции.РеквизитИсточника"), Истина);
	
	Элемент.ВыбиратьТип     = РезСтр.ВыбиратьТип;					  
	Элемент.ОграничениеТипа = РезСтр.ОграничениеТипа;
	
КонецПроцедуры // СубконтоИсточникНачалоВыбора()

// Подключаемый обработчик событий. 
// Подробности см. ОМ.бит_МеханизмТрансляции.ДобавитьДинамическиеКолонкиТаблицыТрансляции.
// 
&НаКлиенте
Процедура Подключаемый_СубконтоПриемникНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	
	ИмяТабличногоПоля     = "ТаблицаПравила";
	ТекущаяСтрока         = Элементы.ТаблицаПравила.ТекущиеДанные;
    ИмяКолонки            = СтрЗаменить(Элемент.Имя, ИмяТабличногоПоля+"_", "");		 		
	
	РезСтр = СубконтоНачалоВыбора(ИмяТабличногоПоля
						  ,ТекущаяСтрока.ПолучитьИдентификатор()
						  ,ИмяКолонки
						  ,ПредопределенноеЗначение("Перечисление.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника")
						  ,Истина);
						  
	
	СтандартнаяОбработка = Ложь;
	
	ОткрытьФормуВыбораЗначения(ТекущаяСтрока, ИмяКолонки, РезСтр.ОграничениеТипа);
	
КонецПроцедуры // СчетИсточникПриИзменении()  

// Подключаемый обработчик событий. 
// Подробности см. ОМ.бит_МеханизмТрансляции.ДобавитьДинамическиеКолонкиТаблицыТрансляции.
// 
&НаКлиенте
Процедура Подключаемый_ПолеПриемникаНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	
	ИмяТабличногоПоля = "ТаблицаПравила";
	ТекущаяСтрока     = Элементы.ТаблицаПравила.ТекущиеДанные;
	ИмяКолонки        = СтрЗаменить(Элемент.Имя, ИмяТабличногоПоля+"_", "");		 		
	
	СтандартнаяОбработка = Ложь;
	
	ОграничениеТипа = Новый ОписаниеТипов();	
	Если фКолонкиПравила.Свойство(ИмяКолонки) Тогда
		
		ОграничениеТипа = фКолонкиПравила[ИмяКолонки];
		
	КонецЕсли; 
	
	ОткрытьФормуВыбораЗначения(ТекущаяСтрока, ИмяКолонки, ОграничениеТипа);
	
КонецПроцедуры // ПолеПриемникаНачалоВыбора()  

#КонецОбласти

#Область РаботаСExcel

&НаКлиенте
Процедура Excel_ЗагрузитьПравилаТрансляции(Команда)
	
	Если ПроверитьШапкуПередРаботойСExcel() Тогда
		
		Если ТаблицаПравила.ПолучитьЭлементы().Количество() > 0 Тогда
			
			Оповещение = Новый ОписаниеОповещения("ВопросОчиститьПравилТрансляцииЗавершение", ЭтотОбъект);
			ТекстВопроса = НСтр("ru = 'Перед загрузкой данных из Excel таблица правил трансляции будет очищена. Продолжить?'");
			ПоказатьВопрос(Оповещение, ТекстВопроса, РежимДиалогаВопрос.ДаНет, 15, КодВозвратаДиалога.Нет);
			
		Иначе
			
			ЗагрузитьПравилаТрансляцииКлиент();
		
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // Excel_ЗагрузитьПравилаТрансляции()

&НаКлиенте
Процедура Excel_ДобавитьПравилаТрансляции(Команда)
	
	Если ПроверитьШапкуПередРаботойСExcel() Тогда
		
		ЗагрузитьПравилаТрансляцииКлиент(); 
	
	КонецЕсли;
	
КонецПроцедуры // Excel_ДобавитьПравилаТрансляции()

// Процедура - обработка ответа на  вопрос об очистке данных дерева правил трансляции (ТаблицаПравила).
// 
&НаКлиенте
Процедура ВопросОчиститьПравилТрансляцииЗавершение(Результат, ДополнительныеПараметры) Экспорт
	
	Если Результат = КодВозвратаДиалога.Да Тогда
		
		ТаблицаПравила.ПолучитьЭлементы().Очистить();
		ЗагрузитьПравилаТрансляцииКлиент();
		
	КонецЕсли;	
	
КонецПроцедуры // ВопросОчиститьПравилТрансляцииЗавершение()

&НаКлиенте
Процедура Excel_ВыгрузитьШаблонПравилТрансляции(Команда)
	
	Если ПроверитьШапкуПередРаботойСExcel() Тогда
		
		ВыгрузитьШаблонПравилТрансляцииКлиент(Ложь);
		
	КонецЕсли;    	
		 
КонецПроцедуры

&НаКлиенте
Процедура Excel_ВыгрузитьШаблонИДанныеПравилТрансляции(Команда)
	
	Если ПроверитьШапкуПередРаботойСExcel() Тогда
		
		ВыгрузитьШаблонПравилТрансляцииКлиент(Истина);
		
	КонецЕсли;
	
КонецПроцедуры // Excel_ВыгрузитьШаблонИДанныеПравилТрансляции()

&НаКлиенте
Функция ПроверитьШапкуПередРаботойСExcel()

	МожноРаботатьСExcel = Истина;
	
	Если НЕ ЗначениеЗаполнено(Объект.НастройкаПравилТрансляции) Тогда
		
		ТекстСообщения = Нстр("ru = 'Не заполнена настройка правил трансляции.'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		
		МожноРаботатьСExcel = Ложь;
		
	КонецЕсли;

	Возврат МожноРаботатьСExcel;
	
КонецФункции // ПроверитьШапкуПередРаботойСExcel()

&НаКлиентеНаСервереБезКонтекста
Функция СтруктураОбъекта()
	
	СтруктураОбъекта = Новый Структура; 
	СтруктураОбъекта.Вставить("ВидОбъекта", "Справочники");
	СтруктураОбъекта.Вставить("ИмяОбъекта", "бит_ПравилаТрансляции");
	СтруктураОбъекта.Вставить("ИмяТч",);
	СтруктураОбъекта.Вставить("ИмяРеквизитаФормы", "ТаблицаПравил");
	
	Возврат СтруктураОбъекта;

КонецФункции

// Функция определяет структуру полей для загрузки/выгрузки дерева правил трансляции (ТаблицаПравила).
//
// Параметры:
//  МассивИсключений - Массив
//
// Возвращаемое значение:
//  Структура.
//
&НаСервере
Функция ОпределитьСтруктуруПолей(СтруктураОбъекта = Неопределено)
	
	МассивИсключений = Новый Массив;
	МассивИсключений.Добавить("ИД");
		
	СтруктураПолей = Новый Структура;
	СоставСтруктураПоля = "Имя, Синоним, СтрТип, СоставнойТип, ПримитивныйТип, Длина, Точность, НастройкиОбмена, ЭтоСубконто, ПолеСчет, ИдСубконто";
	НастройкиОбмена 	= бит_ОбменДаннымиЭксельСервер.СформироватьНастройкиОбмена();
	
	НастройкиКолонок = ПолучитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);
	
	Для каждого Колонка Из НастройкиКолонок Цикл
		
		ИмяКолонки = Колонка.ИмяКолонки;
		
		Если МассивИсключений.Найти(ИмяКолонки) = Неопределено Тогда
			
			ТипыЗначенийСтр = Колонка.ТипыЗначенийСтр;
			ТипыЗначений    = Колонка.ТипыЗначенийВФорме;
			СоставнойТип    = ТипыЗначений.Типы().Количество() > 1;
			Если СоставнойТип Тогда
				ПримитивныйТип = Ложь;
			Иначе
			  	ПервыйТип      = ТипыЗначений.Типы()[0];
				ПримитивныйТип = бит_ОбщегоНазначения.ЭтоПримитивныйТип(ПервыйТип); 							
			КонецЕсли;  	
						
			ЭтоСубконто = ?(Колонка.ЭтоСубконто = Неопределено, Ложь, Колонка.ЭтоСубконто);
			 			
			СтруктураПоля = бит_ОбменДаннымиЭксельСервер.СоздатьСтруктуруПоля();
			СтруктураПоля.Вставить("Имя"		 			 , ИмяКолонки);
			СтруктураПоля.Вставить("Синоним"				 , Колонка.НаименованиеКолонки);
			СтруктураПоля.Вставить("ТипРеквизита"			 , ТипыЗначений);
			СтруктураПоля.Вставить("СтрТип"					 , ТипыЗначенийСтр);
			СтруктураПоля.Вставить("НастройкиОбмена"		 , НастройкиОбмена);
			СтруктураПоля.Вставить("СоставнойТип"			 , СоставнойТип);
			СтруктураПоля.Вставить("ПримитивныйТип"			 , ПримитивныйТип);
			СтруктураПоля.Вставить("ЭтоСубконто"			 , ЭтоСубконто);
				
			Если ЭтоСубконто Тогда
				// Для субконто сохраняем имя поля счета, связанного с субконто
				СтруктураПоля.Вставить("ИдСубконто", Прав(ИмяКолонки, 1));
			КонецЕсли;
							
			СтруктураПолей.Вставить(ИмяКолонки, СтруктураПоля);
			
			Если ИмяКолонки = "НомерСтроки" Тогда
				// Дополнительная колонка "Уровень" - для сохранения уровней дерева.
				бит_ОбменДаннымиЭксельСервер.ДобавитьДопКолонку_Уровень(СтруктураПолей);	
			КонецЕсли;
		КонецЕсли;  			
	КонецЦикла;  	
		
	Возврат СтруктураПолей;  	
	
КонецФункции // ОпределитьСтруктуруПолей()

&НаСервере
Функция ПоместитьВХранилищеДеревоПравил()

	ДеревоПравил = РеквизитФормыВЗначение("ТаблицаПравила");
	Возврат ПоместитьВоВременноеХранилище(ДеревоПравил, УникальныйИдентификатор);

КонецФункции // ПоместитьВХранилищеДеревоПравил()

// Процедура выполняет действия, необходимые после загрузки данных из Excel.
//
&НаСервере
Процедура ВыполнитьПроцедурыПослеЗагрузкиДанныхДерева()

	ОсвежитьСтрокиДерева(ТаблицаПравила, 0);
	
КонецПроцедуры // ВыполнитьПроцедурыПослеЗагрузкиДанныхДерева()

// Перенумеровывает строки дерева значений и добавляет ИД. 
// 
&НаСервереБезКонтекста
Процедура ОсвежитьСтрокиДерева(ВхСтрока, Сч = 0)
	
	Для Каждого СтрокаТаблицы ИЗ ВхСтрока.ПолучитьЭлементы() Цикл
		
		Сч = Сч + 1;
		СтрокаТаблицы.НомерСтроки = Сч;
		СтрокаТаблицы.ИД = Новый УникальныйИдентификатор;
		ОсвежитьСтрокиДерева(СтрокаТаблицы, Сч);
		
	КонецЦикла;	
	
КонецПроцедуры // ОсвежитьСтрокиДерева

// --------------------------------------------------
// Загрузка

&НаСервере
Функция ЗагрузитьРезультатВДеревоПравилТрансляции(АдресДереваПравил, КолСтрТчПередЗагрузкой)

	// Загрузка результата в тч
	ДеревоПравил = ПолучитьИзВременногоХранилища(АдресДереваПравил);
	ЗначениеВДанныеФормы(ДеревоПравил, ТаблицаПравила);
	
	ВыполнитьПроцедурыПослеЗагрузкиДанныхДерева();

КонецФункции // ЗагрузитьРезультатВДеревоПравилТрансляции()

&НаКлиенте
Процедура ЗагрузитьПравилаТрансляцииКлиент()

	КолСтрТчПередЗагрузкой = ТаблицаПравила.ПолучитьЭлементы().Количество();
	
	СтруктураОбъекта = СтруктураОбъекта();
	СтруктураПолей   = ОпределитьСтруктуруПолей(СтруктураОбъекта);
	
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	Диалог.МножественныйВыбор = Ложь;
	Диалог.Фильтр = "Все файлы Excel (*.xls, *.xlsx)|*.xls; *.xlsx";

	Дополнительно = Новый Структура; 
	Дополнительно.Вставить("КолСтрТчПередЗагрузкой", КолСтрТчПередЗагрузкой);
	Дополнительно.Вставить("СтруктураОбъекта", 		 СтруктураОбъекта);
	Дополнительно.Вставить("СтруктураПолей", 		 СтруктураПолей);
	
	Оповещение = Новый ОписаниеОповещения("ЗагрузитьПравилаТрансляцииЗавершение", ЭтотОбъект, Дополнительно); 
	ФайловаяСистемаКлиент.ПоказатьДиалогВыбора(Оповещение, Диалог);
	
КонецПроцедуры

// Обработчик завершения выбора файлов.
//  См. Синтакс-помощник: ДиалогВыбораФайла.Показать().
//
&НаКлиенте
Процедура ЗагрузитьПравилаТрансляцииЗавершение(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	
	Если ВыбранныеФайлы = Неопределено Тогда
		Возврат;	
	КонецЕсли; 
	
	КолСтрТчПередЗагрузкой = ДополнительныеПараметры.КолСтрТчПередЗагрузкой;
	СтруктураОбъекта 	   = ДополнительныеПараметры.СтруктураОбъекта;
	СтруктураПолей 		   = ДополнительныеПараметры.СтруктураПолей;
	
	Отказ 	 = Ложь; 
	АдресДереваПравил = ПоместитьВХранилищеДеревоПравил();
	
	бит_ОбменДаннымиЭксельКлиентСервер.ЗагрузитьДанныеТчИзExcelКлиент(ВыбранныеФайлы[0], 
		СтруктураОбъекта, АдресДереваПравил, СтруктураПолей, Отказ);
	
	Если НЕ Отказ Тогда
		ЗагрузитьРезультатВДеревоПравилТрансляции(АдресДереваПравил, КолСтрТчПередЗагрузкой);
	КонецЕсли;		
	
	бит_РаботаСДиалогамиКлиент.РазвернутьДеревоПолностью(Элементы.ТаблицаПравила, 
		ТаблицаПравила.ПолучитьЭлементы(), Истина);

КонецПроцедуры

// --------------------------------------------------
// Выгрузка

// Процедура осуществляет работу с файлом Excel по выгрузке шаблона и данных.
// 
// Параметры:
//  ВыгружатьДанныеТч - Булево
// 
&НаКлиенте
Процедура ВыгрузитьШаблонПравилТрансляцииКлиент(ВыгружатьДанныеТч)
	
	СтруктураПолей = ОпределитьСтруктуруПолей();
	
	бит_ОбменДаннымиЭксельКлиентСервер.ВыгрузитьВExcelКлиент(ВыгружатьДанныеТч, СтруктураПолей, ТаблицаПравила);
		
КонецПроцедуры

#КонецОбласти

&НаСервере
Процедура РаскраситьКод()
	
	Модуль = Обработки.бит_РаскрашиваниеКода.Создать();
	РезультатHTML = Модуль.РаскраситьТекст(фКодУсловияТрансляции);
	
КонецПроцедуры
 
&НаКлиентеНаСервереБезКонтекста
Процедура ВычислитьКоличествоИсключений(Форма)

	Форма.КоличествоИсключений = Форма.ТаблицаИсключения.Количество();

КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Процедура ВычислитьКоличествоПравил(Форма)

	Форма.КоличествоПравил = Форма.ТаблицаПравила.ПолучитьЭлементы().Количество();

КонецПроцедуры
 
&НаКлиенте
Функция НастройкаЗаполнена()
	
	НастройкаЗаполнена = Истина;
	Если НЕ ЗначениеЗаполнено(Объект.НастройкаПравилТрансляции) Тогда
		ТекстСообщения = ОбщегоНазначенияКлиентСервер.ТекстОшибкиЗаполнения(,,"Настройка структуры конструктора");
		ОбщегоНазначенияКлиент.СообщитьПользователю(ТекстСообщения,, "Объект.НастройкаПравилТрансляции");
		НастройкаЗаполнена = Ложь;
	КонецЕсли; 
	
	Возврат НастройкаЗаполнена;
	
КонецФункции // НастройкаЗаполнена()

// Процедура назначает новый ИД подчиненным строкам. Рекурсивный вызов. 
// 
// Параметры:
//  СтрокаВерх - СтрокаДереваЗначений.
// 
&НаКлиентеНаСервереБезКонтекста
Процедура ПрисвоитьНовыйИдИерархически(СтрокаВерх)
	
	Если НЕ ТипЗнч(СтрокаВерх) = Тип("ДанныеФормыЭлементДерева") Тогда
	
		 Возврат;
	
	КонецЕсли; 
	
	Для каждого ТекСтрока Из СтрокаВерх.ПолучитьЭлементы() Цикл
		
		ТекСтрока.ИД = Строка(Новый УникальныйИдентификатор);
		
		ПрисвоитьНовыйИдИерархически(ТекСтрока);
		
	КонецЦикла; 	
	
КонецПроцедуры // ПрисвоитьНовыйИдИерархически()

&НаКлиентеНаСервереБезКонтекста
Процедура ПриНачалеРедактированияТаблицыПравил(ТекущаяСтрока, КолонкиТаблицы, Копирование)
	
	Если ТекущаяСтрока = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли; 
	
	ТекущаяСтрока.ИД = Строка(Новый УникальныйИдентификатор);
	
	Если НЕ Копирование Тогда
		Если КолонкиТаблицы.Свойство("ДтКт")  Тогда
			СтрокаРодитель = ТекущаяСтрока.ПолучитьРодителя();
			Если СтрокаРодитель = Неопределено Тогда
				ТекущаяСтрока.ДтКт = ПредопределенноеЗначение("Перечисление.бит_ВидыСоответствия.ДебетКредит");
			Иначе	
				ТекущаяСтрока.ДтКт = СтрокаРодитель.ДтКт;
			КонецЕсли; 
		КонецЕсли; 
		
		Если КолонкиТаблицы.Свойство("СпособЗаполненияСуммы")  Тогда
			ТекущаяСтрока.СпособЗаполненияСуммы = ПредопределенноеЗначение("Перечисление.бит_СпособыЗаполненияСуммПроводокБюджетирования.Сумма");
		КонецЕсли;
	Иначе	
		ПрисвоитьНовыйИдИерархически(ТекущаяСтрока);
	КонецЕсли; 
	
КонецПроцедуры // ПриНачалеРедактированияТаблицыПравил()

// Перенумеровывает строки таблицы значений. 
// 
&НаКлиентеНаСервереБезКонтекста
Процедура ПеренумероватьСтрокиТаблицы(ТекущаяТаблица, Сч = 0)
	
	Для Каждого СтрокаТаблицы ИЗ ТекущаяТаблица Цикл
		Сч = Сч + 1;
		СтрокаТаблицы.НомерСтроки = Сч;
	КонецЦикла;	
	
КонецПроцедуры	

// Перенумеровывает строки дерева значений. 
// 
&НаКлиентеНаСервереБезКонтекста
Процедура ПеренумероватьСтрокиДерева(ВхСтрока, Сч = 0)
	
	Для Каждого СтрокаТаблицы ИЗ ВхСтрока.ПолучитьЭлементы() Цикл
		Сч = Сч + 1;
		СтрокаТаблицы.НомерСтроки = Сч;
		ПеренумероватьСтрокиДерева(СтрокаТаблицы, Сч);
	КонецЦикла;	
	
КонецПроцедуры

&НаКлиенте
Процедура СкопироватьИерархию(СтрокаРодитель,СтрокаКопирования, ИндексВставки = Неопределено)
	
	Если ТипЗнч(ИндексВставки) = Тип("Число") Тогда
		НоваяСтрока = СтрокаРодитель.ПолучитьЭлементы().Вставить(ИндексВставки);
	Иначе	
		НоваяСтрока = СтрокаРодитель.ПолучитьЭлементы().Добавить();
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаКопирования);
	
	Для каждого СтрокаПодчиненная Из СтрокаКопирования.ПолучитьЭлементы() Цикл
		
		СкопироватьИерархию(НоваяСтрока, СтрокаПодчиненная);
		
	КонецЦикла; 
	
КонецПроцедуры // СкопироватьИерархию()

// Процедура заполняет таблицу настроек колонок правил трансляции и помещает ее во временное хранилище.
// 
&НаСервере
Функция ЗаполнитьТаблицуНастроек(НастройкиПравилТрансляции)
	
	ТабВрем = Неопределено;
	
	Если ЗначениеЗаполнено(НастройкиПравилТрансляции) Тогда
		ТабВрем = бит_МеханизмТрансляции.ПолучитьКолонкиТрансляции(Объект.НастройкаПравилТрансляции, Истина);
		фАдресТаблицыНастройкиКолонок = ПоместитьВоВременноеХранилище(ТабВрем, УникальныйИдентификатор);
	КонецЕсли;
	
	Возврат ТабВрем;
	
КонецФункции	

// Процедура получает таблицу настроек колонок правил трансляции.
// 
&НаСервере
Функция ПолучитьТаблицуНастроек(НастройкиПравилТрансляции) 
	
	ТабВрем = Неопределено;
	
	Если ЭтоАдресВременногоХранилища(фАдресТаблицыНастройкиКолонок) Тогда
		ТабВрем = ПолучитьИзВременногоХранилища(фАдресТаблицыНастройкиКолонок);
	КонецЕсли;	
	
	Если НЕ ТипЗнч(ТабВрем) = Тип("ТаблицаЗначений") Тогда
		ТабВрем = ЗаполнитьТаблицуНастроек(НастройкиПравилТрансляции);
	КонецЕсли;
	
	Возврат ТабВрем;
	
КонецФункции	

&НаСервере
Процедура ОбновитьТаблицуИсключений()
	
	ТаблицаИсключения.Очистить();
	
	// Перерисуем колонки
	ВидыКолонок = Новый Массив;
	ВидыКолонок.Добавить(Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитИсточника);
	ВидыКолонок.Добавить(Перечисления.бит_ВидыКолонокПравилТрансляции.Прочее);
	
	НастройкиКолонок  = ПолучитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);
	
	Если НастройкиКолонок = Неопределено Тогда
		Возврат;
	КонецЕсли;		
	
	бит_МеханизмТрансляции.СоздатьКолонкиТаблицыТрансляции(ЭтотОбъект, Элементы, НастройкиКолонок, "ТаблицаИсключения", Истина, ВидыКолонок);
	
	// Реквизитный состав таблиц "" и "" совпадает. При копировании строк 
	// нужно наследовать чтолько часть.
	ЗначимыеПоляИсключений = "";
	Для каждого СтрокаТаблицы Из НастройкиКолонок Цикл
		Если ВидыКолонок.Найти(СтрокаТаблицы.ВидКолонки) <> Неопределено Тогда
			Разделитель = ?(ПустаяСтрока(ЗначимыеПоляИсключений),"",",");
			ЗначимыеПоляИсключений = ЗначимыеПоляИсключений + Разделитель + СтрокаТаблицы.ИмяКолонки;
		КонецЕсли; 
	КонецЦикла; 
	
	// Восстановим значения в колонках таблицы исключений.
	ТекОб 	= РеквизитФормыВЗначение("Объект");
	ТабВрем = РеквизитФормыВЗначение("ТаблицаИсключения");
	ТекОб.ВосстановитьТаблицуИсключений(ТабВрем);
	
	ЗначениеВДанныеФормы(ТабВрем, ТаблицаИсключения);
	КоличествоИсключений = 0;
	ПеренумероватьСтрокиТаблицы(ТаблицаИсключения, КоличествоИсключений);	
	
	фКолонкиИсключения = Новый Структура;
	Для Каждого Колонка ИЗ ТабВрем.Колонки Цикл
		
		фКолонкиИсключения.Вставить(Колонка.Имя);
		
		// добавлеям кнопку выпадающего списка.
		Если СтрНайти(Колонка.Имя, "Счет") > 0 ИЛИ СтрНайти(Колонка.Имя, "ДтКт") > 0 Тогда
			ЭлементРед = Элементы.Найти("ТаблицаИсключения_" + Колонка.Имя);
			Если Не ЭлементРед = Неопределено Тогда
				ЭлементРед.КнопкаВыпадающегоСписка = Истина;
				ЭлементРед.КнопкаОчистки = Ложь;
			КонецЕсли;
		КонецЕсли;	
	КонецЦикла;	
	
	Элементы.ТаблицаИсключенияПустойРеквизит.Видимость = ?(ТабВрем.Колонки.Количество() = 0, Истина, Ложь);
	
КонецПроцедуры // ОбновитьТаблицуПравил()

// Процедура выполняет генерация кода условия трансляции по настройкам правила трансляции. 
// 
&НаСервере
Процедура ГенерироватьКод()

	ТабПравилаВрем    = РеквизитФормыВЗначение("ТаблицаПравила");
	ТабИсключенияВрем = РеквизитФормыВЗначение("ТаблицаИсключения");
	НастройкиКолонок  = ПолучитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);
	ТекущийОбъект 	  = РеквизитФормыВЗначение("Объект");
    Объект.КодУсловияТрансляции = ТекущийОбъект.ГенерироватьКод(ТабПравилаВрем, ТабИсключенияВрем, НастройкиКолонок);

	УстановитьКодТрансляции(Объект.КодУсловияТрансляции, фПоказатьМаркеры);
	
КонецПроцедуры // ГенерироватьКод()

// Процедура устанавливает в табличное поле "ПолеКод" сгенерированный код правил трансляции. 
// Существует возможность исключить маркеры отладки.
// 
// Параметры:
//  ТекстКода  - Строка
//  ПоказыватьМаркеры  - Булево
// 
&НаСервере
Процедура УстановитьКодТрансляции(ТекстКода,ПоказыватьМаркеры = Ложь)

	Если ПоказыватьМаркеры Тогда
		фКодУсловияТрансляции = ТекстКода;
	Иначе	
		
		Маркер = "// #Маркер{";
		ТекстДляУстановки = "";
		КоличествоСтрок = СтрЧислоСтрок(ТекстКода);
		
		Для Сч = 1 По КоличествоСтрок Цикл
			ТекСтрока = СтрПолучитьСтроку(ТекстКода,Сч);
			Если Найти(ТекСтрока,Маркер)=0 Тогда
				ТекстДляУстановки = ТекстДляУстановки+ТекСтрока+Символы.ПС;
			КонецЕсли; 
		КонецЦикла; 
		фКодУсловияТрансляции = ТекстДляУстановки;
	КонецЕсли; 

	РаскраситьКод();
	
	КодУстановлен = Истина; // Отложенный вывод кода при переходе на страницу.
	
КонецПроцедуры

&НаСервере
Процедура ОбновитьТаблицуПравил()
	
	ТаблицаПравила.ПолучитьЭлементы().Очистить();
	
	// Перерисуем колонки
	НастройкиКолонок  = ПолучитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);
	
    Если НастройкиКолонок = Неопределено Тогда
    	Возврат;
    КонецЕсли;	
    
	бит_МеханизмТрансляции.СоздатьКолонкиТаблицыТрансляции(ЭтотОбъект, Элементы, НастройкиКолонок, "ТаблицаПравила", Истина);
    
    // Восстановим настройки
    ТекОб = РеквизитФормыВЗначение("Объект");
    ТабВрем = РеквизитФормыВЗначение("ТаблицаПравила");
    ТекОб.ВосстановитьТаблицуПравил(ТабВрем);
    
    ЗначениеВДанныеФормы(ТабВрем, ТаблицаПравила);
    КоличествоПравил = 0;
    ПеренумероватьСтрокиДерева(ТаблицаПравила, КоличествоПравил);
	
    фКолонкиПравила = Новый Структура;
    Для Каждого Колонка ИЗ ТабВрем.Колонки Цикл
    	
    	фКолонкиПравила.Вставить(Колонка.Имя, Колонка.ТипЗначения);
    	
    	// добавлеям кнопку выпадающего списка.
    	Если СтрНайти(Колонка.Имя, "Счет") > 0 ИЛИ СтрНайти(Колонка.Имя, "ДтКт") > 0 Тогда
    		ЭлементРед = Элементы.Найти("ТаблицаПравила_" + Колонка.Имя);
    		Если Не ЭлементРед = Неопределено Тогда
    			ЭлементРед.КнопкаВыпадающегоСписка = Истина;
    			ЭлементРед.КнопкаОчистки = Ложь;
    		КонецЕсли;
    	КонецЕсли;	
    КонецЦикла;	
    
    Элементы.ТаблицаПравилаПустойРеквизит.Видимость = ?(ТабВрем.Колонки.Количество() = 0, Истина, Ложь);
	
КонецПроцедуры // ОбновитьТаблицуПравил()

&НаСервере
Процедура ЗаполнитьЗначенияРеквизитов(ТекущийОбъект, СтрокаРодитель)
	
	Для каждого СтрокаПравила Из СтрокаРодитель.ПолучитьЭлементы() Цикл
		
		НоваяСтрока = ТекущийОбъект.ИерархияСтрок.Добавить();
		НоваяСтрока.ИД = СтрокаПравила.ИД;
		ТекРодитель = СтрокаПравила.ПолучитьРодителя();
		Если ТекРодитель <> Неопределено Тогда
			
			НоваяСтрока.ИДРодителя = ТекРодитель.ИД;
			
		КонецЕсли; 
		
		ЗаполнитьЗначенияРеквизитовПоСтроке(ТекущийОбъект, СтрокаПравила, фКолонкиПравила, "Правила");
		
		ЗаполнитьЗначенияРеквизитов(ТекущийОбъект, СтрокаПравила);
		
	КонецЦикла; 
	
КонецПроцедуры // ЗаполнитьЗначенияРеквизитов()

&НаСервере
Процедура ЗаполнитьЗначенияРеквизитовПоСтроке(ТекущийОбъект, СтрокаПравила, КолонкиТаблицы, ИмяТаблицы)
	
	Для каждого КиЗ Из КолонкиТаблицы Цикл
		
		ИмяКолонки = КиЗ.Ключ;
		Если ИмяКолонки = "ИД" Тогда
			
			Продолжить;
			
		КонецЕсли; 
		
		ТекущееЗначение = СтрокаПравила[ИмяКолонки];
		Если ЗначениеЗаполнено(ТекущееЗначение) Тогда
			
			СтрОтбор = Новый Структура("ИД,ИмяКолонки",СтрокаПравила.ИД,ИмяКолонки);
			МассивСтрокТЧ = ТекущийОбъект.ЗначенияРеквизитов.НайтиСтроки(СтрОтбор);
			Если МассивСтрокТЧ.Количество() > 0 Тогда
				СтрокаТЧ = МассивСтрокТЧ[0];
			Иначе
				СтрокаТЧ = ТекущийОбъект.ЗначенияРеквизитов.Добавить();
			КонецЕсли; 
			
			СтрокаТЧ.ИД         = СтрокаПравила.ИД;
			СтрокаТЧ.ИмяКолонки = ИмяКолонки;
			СтрокаТЧ.Значение   = ТекущееЗначение;
			СтрокаТЧ.ИмяТаблицы = ИмяТаблицы;
			
		КонецЕсли; 
		
	КонецЦикла; // По колонкам таблицы правил
	
КонецПроцедуры // ЗаполнитьЗначенияРеквизитовПоСтроке()


// Процедура устанавливает отбор по регистру приемнику для выбора шаблона движений. 
// 
&НаСервере
Процедура УстановитьОтборШаблонаДвижений()
	
	Если НЕ Элементы.Найти("ТаблицаПравила_ШаблонДвижений") = Неопределено Тогда
		
		// Найдем элемент справочника бит_ВидыРеквизитовДвижений, соответствующий Приемнику.
		Регистр = Справочники.бит_ВидыРеквизитовДвижений.ПустаяСсылка();			   		
		Имена = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(Объект.Приемник.ИмяОбъектаПолное);
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ИмяРегистра", Объект.Приемник.ИмяОбъекта);
		Запрос.УстановитьПараметр("ВидРегистра", Имена.ИмяКоллекции);
		Запрос.Текст = "ВЫБРАТЬ
		|	бит_ВидыРеквизитовДвижений.Ссылка
		|ИЗ
		|	Справочник.бит_ВидыРеквизитовДвижений КАК бит_ВидыРеквизитовДвижений
		|ГДЕ
		|	бит_ВидыРеквизитовДвижений.ЭтоГруппа
		|	И бит_ВидыРеквизитовДвижений.ИмяРегистра = &ИмяРегистра
		|	И бит_ВидыРеквизитовДвижений.ВидРегистра = &ВидРегистра";
		
		
		Результат = Запрос.Выполнить();
		Выборка = Результат.Выбрать();
		
		Если Выборка.Следующий() Тогда
			
			Регистр = Выборка.Ссылка;
			
		КонецЕсли; 
		
		// Установим параметры выбора.
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("Регистр", Регистр);
		бит_ОбщегоНазначенияКлиентСервер.УстановитьПараметрыВыбораЭлемента(Элементы.ТаблицаПравила_ШаблонДвижений, СтруктураПараметров);
		
	КонецЕсли; 
	
КонецПроцедуры // УстановитьОтборШаблонаДвижений()

// Процедура обрабатывает изменение структуры конструктора правил трансляции.
// 
&НаСервере
Процедура ИзменениеНастройки()
	
	ЗаполнитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);
	
	РеквизитыНастройки = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Объект.НастройкаПравилТрансляции, "Источник, Приемник");
	РеквизитыИсточника = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(РеквизитыНастройки.Источник, "ВидОбъекта, ИмяОбъекта");
	
	Объект.Источник = РеквизитыНастройки.Источник;
	Объект.Приемник = РеквизитыНастройки.Приемник;
	
	// Установим тип основного счета
	Если РеквизитыИсточника.ВидОбъекта = Перечисления.бит_ВидыОбъектовСистемы.РегистрБухгалтерии Тогда
		
		 ИмяПланаСчетов = Метаданные.РегистрыБухгалтерии[РеквизитыИсточника.ИмяОбъекта].ПланСчетов.Имя; 
		 ЗначениеПоУмолчанию = ПланыСчетов[ИмяПланаСчетов].ПустаяСсылка();
		 Если ТипЗнч(Объект.ОсновнойСчет) <> ТипЗнч(ЗначениеПоУмолчанию) Тогда
		    Объект.ОсновнойСчет = ЗначениеПоУмолчанию;
		 КонецЕсли; 
	КонецЕсли; 
	
	ОбновитьТаблицуПравил();
	ОбновитьТаблицуИсключений();
	
	УстановитьОтборШаблонаДвижений();
	
КонецПроцедуры	

// Процедура обновляет колонки таблицы Правила. 
// 
&НаСервере
Процедура ПравилаОбновитьКолонки()

	ЗаполнитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);	
	
	ОбновитьТаблицуПравил();

КонецПроцедуры // ПравилаОбновитьКолонки()

// Процедура обновляет колонки таблицы Исключения. 
// 
&НаСервере
Процедура ИсключенияОбновитьКолонки()

	ЗаполнитьТаблицуНастроек(Объект.НастройкаПравилТрансляции);	
	
	ОбновитьТаблицуИсключений();

КонецПроцедуры // ИсключенияОбновитьКолонки()

#КонецОбласти 