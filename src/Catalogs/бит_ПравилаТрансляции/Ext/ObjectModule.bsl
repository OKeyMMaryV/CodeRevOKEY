#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ОбработчикиСобытий

Процедура ОбработкаЗаполнения(ДанныеЗаполнения, ТекстЗаполнения, СтандартнаяОбработка)
	
	Если ТипЗнч(ДанныеЗаполнения) = Тип("Структура")  Тогда
		ЗаполнитьЗначенияСвойств(ЭтотОбъект, ДанныеЗаполнения);
	ИначеЕсли ТипЗнч(ДанныеЗаполнения) = Тип("СправочникСсылка.бит_СтруктураКонструктораПравилТрансляции")  Тогда
		ЗаполнитьПоНастройке(ДанныеЗаполнения);
	КонецЕсли; 
	
КонецПроцедуры
	
Процедура ПередЗаписью(Отказ)
	
	Если ОбменДанными.Загрузка Тогда
		Возврат;			
	КонецЕсли; 
		
	бит_ук_СлужебныйСервер.РегистрацияНачалоСобытия(Отказ, ДополнительныеСвойства);
		
КонецПроцедуры
	
Процедура ПриЗаписи(Отказ)
	
	//ОК Довбешка Т. 29.12.2014
	//Если ОбменДанными.Загрузка Тогда
	Если ОбменДанными.Загрузка ИЛИ ЭтоГруппа Тогда
		// В случае выполнения обмена данными не производить проверку.
		Возврат;			
	КонецЕсли; 
		
	бит_ук_СлужебныйСервер.РегистрацияПриЗаписи(Отказ, ДополнительныеСвойства, Метаданные().ПолноеИмя());
	//ОК
	КодУсловияТрансляцииСжатый = (ЗначениеВСтрокуВнутр(Новый ХранилищеЗначения(КодУсловияТрансляции,Новый СжатиеДанных(9))));
		
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс
	
// Процедура восстанавливает дерево правил трансляции из сохраненных данных.
// 
// Параметры:
//  ТаблицаПравила  - ДеревоЗначений.
// 
Процедура ВосстановитьТаблицуПравил(ТаблицаПравила) Экспорт

	// Восстановим иерархию строк дерева
	Для каждого СтрокаТЧ Из ИерархияСтрок Цикл
		СтрокаПравила = ТаблицаПравила.Строки.Найти(СтрокаТЧ.ИД,"ИД",Истина);
		Если СтрокаПравила = Неопределено Тогда
			СтрокаРодитель= ТаблицаПравила.Строки.Найти(СтрокаТЧ.ИДРодителя,"ИД",Истина);
			Если СтрокаРодитель <> Неопределено Тогда
				СтрокаПравила = СтрокаРодитель.Строки.Добавить();
			Иначе
				СтрокаПравила = ТаблицаПравила.Строки.Добавить();
			КонецЕсли; 
			СтрокаПравила.ИД = СтрокаТЧ.ИД;
		КонецЕсли; 
	КонецЦикла; 
	
	// Восстановим значения в колонках
	КолонкиПравила = ТаблицаПравила.Колонки;
	Для каждого СтрокаТЧ Из ЗначенияРеквизитов Цикл
		
		Если СтрокаТЧ.ИмяТаблицы <> "Правила" Тогда
			 Продолжить;
		КонецЕсли; 
		
		СтрокаПравила = ТаблицаПравила.Строки.Найти(СтрокаТЧ.ИД,"ИД",Истина);		
		Если СтрокаПравила = Неопределено Тогда
			СтрокаПравила = ТаблицаПравила.Строки.Добавить();
			СтрокаПравила.ИД = СтрокаТЧ.ИД;
		КонецЕсли; 
		
		Если КолонкиПравила.Найти(СтрокаТЧ.ИмяКолонки) <> Неопределено Тогда
			СтрокаПравила[СтрокаТЧ.ИмяКолонки] = СтрокаТЧ.Значение;
		КонецЕсли; 
	КонецЦикла; 

КонецПроцедуры

// Процедура восстанавливает таблицу исключений из сохраненных данных.
// 
// Параметры:
//  ТаблицаИсключения  - ТаблицаЗначений.
// 
Процедура ВосстановитьТаблицуИсключений(ТаблицаИсключения) Экспорт

	КолонкиПравила = ТаблицаИсключения.Колонки;
	Для каждого СтрокаТЧ Из ЗначенияРеквизитов Цикл
		
		Если СтрокаТЧ.ИмяТаблицы <> "Исключения" Тогда
			Продолжить;
		КонецЕсли; 
		
		СтрокаИсключения = ТаблицаИсключения.Найти(СтрокаТЧ.ИД,"ИД");		
		Если СтрокаИсключения = Неопределено Тогда
			СтрокаИсключения = ТаблицаИсключения.Добавить();
			СтрокаИсключения.ИД = СтрокаТЧ.ИД;
		КонецЕсли; 
		
		Если КолонкиПравила.Найти(СтрокаТЧ.ИмяКолонки) <> Неопределено Тогда
			СтрокаИсключения[СтрокаТЧ.ИмяКолонки] = СтрокаТЧ.Значение;
		КонецЕсли; 
	КонецЦикла; 

КонецПроцедуры

// Процедура выполняет "перекомпиляцию кода" для текущего элемента.
// 
Процедура ПерекомпилироватьКод() Экспорт

	Если ЭтоГруппа Тогда
		Возврат;
	КонецЕсли; 
	
	ТаблицаКолонки = бит_МеханизмТрансляции.ПолучитьКолонкиТрансляции(НастройкаПравилТрансляции);
	
	ТаблицаПравила = Новый ДеревоЗначений;
	бит_МеханизмТрансляции.ИнициализироватьТаблицуНастройки(ТаблицаПравила,ТаблицаКолонки);
	ВосстановитьТаблицуПравил(ТаблицаПравила);
	
	ТаблицаИсключения = Новый ТаблицаЗначений;
	
	ВидыКолонок = Новый Массив;
	ВидыКолонок.Добавить(Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитИсточника);
	ВидыКолонок.Добавить(Перечисления.бит_ВидыКолонокПравилТрансляции.Прочее);	
	
	бит_МеханизмТрансляции.ИнициализироватьТаблицуНастройки(ТаблицаИсключения,ТаблицаКолонки,ВидыКолонок);
	ВосстановитьТаблицуИсключений(ТаблицаИсключения);
	
	КодУсловияТрансляции = ГенерироватьКод(ТаблицаПравила,ТаблицаИсключения,ТаблицаКолонки,Истина);

КонецПроцедуры // ПерекомпилироватьКод()

// Процедура формирует код условия по настройке правил трансляции.
// 
// Параметры:
//  ТаблицаПравила    - ТаблицаЗначений.
//  ТаблицаИсключения - ТаблицаЗначений.
//  ТаблицаКолонки    - ТаблицаЗначений.
//  ДобавлятьМаркеры  - Булево.
// 
Функция ГенерироватьКод(ТаблицаПравила,ТаблицаИсключения,ТаблицаКолонки,ДобавлятьМаркеры = Истина) Экспорт
	
	НовыйКод = "";	
	УчитыватьКорреспонденцию = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(НастройкаПравилТрансляции, "УчитыватьКорреспонденцию");
	
	Если ТаблицаКолонки.Количество() > 1000 Тогда
		ТаблицаКолонки.Индексы.Добавить("ИмяКолонки");	
	КонецЕсли; 
	
	Если УчитыватьКорреспонденцию Тогда
		// Исключения	
		РезКод = ГенерироватьКодИсключений(ТаблицаИсключения,ТаблицаКолонки,УчитыватьКорреспонденцию,"",ДобавлятьМаркеры);
		ДобавитьБлокВКод(НовыйКод,РезКод,"// Исключения");
		
		// Правила трансляции
		РезКод = ГенерироватьКодПоУровню(ТаблицаПравила,ТаблицаПравила.Колонки,ТаблицаКолонки,УчитыватьКорреспонденцию,"",ДобавлятьМаркеры);
		ДобавитьБлокВКод(НовыйКод,РезКод,"// Правила трансляции");
	Иначе
		// Исключения	
		РезКод = ГенерироватьКодИсключений(ТаблицаИсключения,ТаблицаКолонки,УчитыватьКорреспонденцию,"Дт",ДобавлятьМаркеры);
		ДобавитьБлокВКод(НовыйКод,РезКод,"// Исключения по ДТ");
		
		РезКод = ГенерироватьКодИсключений(ТаблицаИсключения,ТаблицаКолонки,УчитыватьКорреспонденцию,"Кт",ДобавлятьМаркеры);
		ДобавитьБлокВКод(НовыйКод,РезКод,"// Исключения по КТ");	
		
		
		// Правила трансляции
		РезКод = ГенерироватьКодПоУровню(ТаблицаПравила,ТаблицаПравила.Колонки,ТаблицаКолонки,УчитыватьКорреспонденцию,"Дт",ДобавлятьМаркеры);
		ДобавитьБлокВКод(НовыйКод,РезКод,"// Правила трансляции по ДТ");	
		
		РезКод = ГенерироватьКодПоУровню(ТаблицаПравила,ТаблицаПравила.Колонки,ТаблицаКолонки,УчитыватьКорреспонденцию,"Кт",ДобавлятьМаркеры);
		ДобавитьБлокВКод(НовыйКод,РезКод,"// Правила трансляции по КТ");	
	КонецЕсли; 
	
	Возврат НовыйКод;
	
КонецФункции // ГенерироватьКод()

// Функция формирует код по строке правил трансляции.
// 
// Параметры:
//  СтрокаПравила     - СтрокаТаблицыЗначений.
//  КолонкаНастройки  - КолонкаТаблицыЗначений.
//  ТаблицаКолонки    - ТаблицаЗначений.
//  ТаблицаПравила    - ТаблицаЗначений.
//  ДтКт              - Строка.
// 
// Возвращаемое значение:
//   ТекстКод     - Строка
// 
Функция ГенерироватьКодПоСтрокеПравил(СтрокаПравила,КолонкиПравила,ТаблицаКолонки,УчитыватьКорреспонденцию,ДтКт)  Экспорт
	
	ТекстРезультат = "";
	ТекстУсловие   = "";	
	Ном 		   = 0;
	
	Для каждого КолонкаПравила Из КолонкиПравила Цикл
		
		ИмяКолонки 		= КолонкаПравила.Имя;
		ЗначениеКолонки = СтрокаПравила[ИмяКолонки];
		
		Если ЗначениеЗаполнено(ЗначениеКолонки) Тогда
			
			// Найдем колонку настройки
			КолонкаНастройки = ТаблицаКолонки.Найти(ИмяКолонки,"ИмяКолонки");
			
			Если КолонкаНастройки <> Неопределено Тогда
				
				Если КолонкаНастройки.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитИсточника Тогда
					
					ТекстУсловие = ТекстУсловие+?(Ном>0,Символы.ПС+Символы.Таб+" И","");
					ТекстУсловие = ТекстУсловие+СформироватьКодУсловияПоКолонке(СтрокаПравила,КолонкаНастройки,ЗначениеКолонки,ИмяКолонки,УчитыватьКорреспонденцию,ДтКт);
					Ном = Ном + 1;
					
				ИначеЕсли КолонкаНастройки.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника Тогда
					
					Если СтрНайти(ИмяКолонки, "ИмяВидаСубконто") = 0 Тогда 
						
						Фрагмент = СформироватьКодУстановкиЗначенийПоКолонке(СтрокаПравила, КолонкаНастройки, 
										ЗначениеКолонки,ИмяКолонки,ТаблицаКолонки,УчитыватьКорреспонденцию,ДтКт);
						ТекстРезультат = ТекстРезультат + Фрагмент;
					КонецЕсли; 
					
				ИначеЕсли КолонкаНастройки.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.ДополнительныеДанные Тогда
					
					Фрагмент = СформироватьКодУстановкиДополнительныхДанных(СтрокаПравила, КолонкаНастройки, 
									ЗначениеКолонки, ИмяКолонки, УчитыватьКорреспонденцию, ДтКт);
					ТекстРезультат = ТекстРезультат + Фрагмент;
					
				Иначе
					Если ИмяКолонки = "ПроизвольноеУсловие" Тогда
						
						 Фрагмент 	  = ?(ПустаяСтрока(ТекстУсловие),"", Символы.ПС + Символы.Таб + " И");
						 //ОКЕЙ Первухин В.С. (ПервыйБИТ) Начало 2020-03-29 (#НТП_БП03_ФР03)
						 //ТекстУсловие = ТекстУсловие + Фрагмент + " " + ЗначениеКолонки;
						 ТекстУсловие = ТекстУсловие + Фрагмент + " " + ок_МеханизмТрансляции.СформироватьПредставлениеПроизвольногоУсловия(ЗначениеКолонки, ДтКт);
						 //ОКЕЙ Первухин В.С. (ПервыйБИТ) Конец 2020-03-29 (#НТП_БП03_ФР03)
						 
					ИначеЕсли ИмяКолонки = "ИспользоватьАналитикуКорр" Тогда
						
						Если СтрокаПравила.ИспользоватьАналитикуКорр = ИСТИНА Тогда
						
							 ТекстРезультат = ТекстРезультат + Символы.Таб + "флИспользоватьАналитикуКорр = Истина;" + Символы.ПС;
						
						КонецЕсли; 
						
					ИначеЕсли ИмяКолонки = "ШаблонДвижений" Тогда
						Фрагмент 	   = СформироватьПредставлениеЗначения(ЗначениеКолонки, СтрокаПравила.ИД, ИмяКолонки,ДтКт);
						ТекстРезультат = ТекстРезультат + Символы.Таб + "ВыполнитьШаблонДвижения(Источник, ЗаписьИсточник, " + Фрагмент + ");" + Символы.ПС;
						
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; // Нашли колонку настройки
		КонецЕсли; // В таблице правил заполнено значение
	КонецЦикла; // По колонкам таблицы правил 

	// Текст произвольного условия
	ТекстПроизвольноеУсловие = СформироватьКодПроизвольногоУсловия(СтрокаПравила,КолонкиПравила,УчитыватьКорреспонденцию,ДтКт);
	
    // Сборка текста кода по строке 
	ТекстКод = "";
	Если НЕ ПустаяСтрока(ТекстУсловие) 
		 ИЛИ НЕ ПустаяСтрока(ТекстПроизвольноеУсловие) Тогда
		 
		Если ПустаяСтрока(ТекстПроизвольноеУсловие) Тогда
			ТекстКод = ТекстКод+ТекстУсловие+" Тогда"+Символы.ПС;
		Иначе
			
			ТекстКод = ТекстКод
					   +?(ПустаяСтрока(ТекстУсловие),"","(")
					   +ТекстУсловие
					   +?(ПустаяСтрока(ТекстУсловие),"",")"+Символы.ПС+Символы.Таб+" И ")
					   +"("
					   +ТекстПроизвольноеУсловие
					   +")"
					   +" Тогда"
					   +Символы.ПС;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ТекстРезультат) Тогда
			
			ТекстКод = ТекстКод+Символы.ПС;
			ТекстКод = ТекстКод+ТекстРезультат;
			
		КонецЕсли; 
		ТекстКод = ТекстКод+Символы.ПС;		
	КонецЕсли; 
	
	Возврат ТекстКод;
	
КонецФункции // ГенерироватьКодПоСтрокеПравил()

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Процедура добавляет блок кода в итоговый код.
// 
// Параметры:
//  ИтоговыйКод  - Строка
//  КодБлока     - Строка
//  КомментарийБлока - Строка
// 
Процедура ДобавитьБлокВКод(ИтоговыйКод,КодБлока,КомментарийБлока)

	Если НЕ ПустаяСтрока(КодБлока) Тогда
	
		ИтоговыйКод = ИтоговыйКод
		          +Символы.ПС
				  +КомментарийБлока
				  +Символы.ПС
				  +КодБлока;		
	
	КонецЕсли; 

КонецПроцедуры // ДобавитьБлокВКод()

// Функция генерирует код по таблице исключений.
// 
// Параметры:
//  ТаблицаИсключения  - ТаблицаЗначений.
//  ТаблицаКолонки     - ТаблицаЗначений.
//  ДтКт               - Строка.
// 
// Возвращаемое значение:
//   РезКод   - Строка
// 
Функция ГенерироватьКодИсключений(ТаблицаИсключения,ТаблицаКолонки,УчитыватьКорреспонденцию,ДтКт,ДобавлятьМаркеры)

	РезКод = "";
	
	ВидСоответствия = ?(ДтКт="Дт",Перечисления.бит_ВидыСоответствия.Дебет,Перечисления.бит_ВидыСоответствия.Кредит);
	
	
	// Исключения
	Если ТаблицаИсключения.Количество()>0 Тогда
		
		Ном = 1;
		Для каждого СтрокаТаблицы Из ТаблицаИсключения Цикл
			
		    ЗначениеДтКт = ?(НЕ УчитыватьКорреспонденцию,СтрокаТаблицы.ДтКт,Перечисления.бит_ВидыСоответствия.ДебетКредит);
			
		   Если НЕ (ЗначениеДтКт = ВидСоответствия 
			    ИЛИ ЗначениеДтКт = Перечисления.бит_ВидыСоответствия.ДебетКредит) Тогда
				
				Продолжить;
				
		   КонецЕсли;		
			
			
			КодУсловия = ГенерироватьКодПоСтрокеПравил(СтрокаТаблицы,ТаблицаИсключения.Колонки,ТаблицаКолонки,УчитыватьКорреспонденцию,ДтКт);
			Если ДобавлятьМаркеры Тогда
				
				ТекстОтладка = СформироватьМаркерОтладки("И",СтрокаТаблицы.ИД);
				
			Иначе
				
				ТекстОтладка = "";
				
			КонецЕсли; 
			Если НЕ ПустаяСтрока(КодУсловия) Тогда
				
				КодПоСтроке = ?(Ном=1,"Если","ИначеЕсли")
				              +" "
							  +КодУсловия
							  +Символы.Таб
							  +"Отказ = Истина;"
							  +Символы.ПС;
							  
				РезКод = РезКод+Символы.ПС+ТекстОтладка+КодПоСтроке;
				
				Ном = Ном+1;
			КонецЕсли; 
			
		КонецЦикла;
		
		Если НЕ ПустаяСтрока(РезКод) Тогда
			
			РезКод = РезКод
			        +Символы.ПС
					+"КонецЕсли;"
					+Символы.ПС;
			
		КонецЕсли;
				
	КонецЕсли; 
	
	Возврат РезКод;
	
КонецФункции // ГенерироватьКодИсключений()

// Функция генерирует код по уровню правил трансляции. Рекурсивный вызов.
// 
// Параметры:
//  СтрокаВерх  - СтрокаДереваЗначений.
//  КолонкиПравил  - КолонкиТаблицыЗначений.
//  ТаблицаКолонки - ТаблицаЗначений.
//  ДтКт           - Строка.
//  ДобавлятьМаркеры   - Булево.
// 
// Возвращаемое значение:
//   ТекстКод   - Строка.
// 
Функция ГенерироватьКодПоУровню(СтрокаВерх,КолонкиПравил,ТаблицаКолонки,УчитыватьКорреспонденцию,ДтКт,ДобавлятьМаркеры)

	НовыйКод 		= "";
	ВидСоответствия = ?(ДтКт = "Дт", Перечисления.бит_ВидыСоответствия.Дебет, Перечисления.бит_ВидыСоответствия.Кредит);
	Счетчик 		= 0;

	Для каждого СтрокаПравила Из СтрокаВерх.Строки Цикл
		
		СтрОтбор 		= Новый Структура("ИмяКолонки", "ДтКт");
		НайденныеСтроки = ТаблицаКолонки.НайтиСтроки(СтрОтбор);
		
		Если УчитыватьКорреспонденцию Тогда
			ЗначениеДтКт = Перечисления.бит_ВидыСоответствия.ДебетКредит;
		Иначе	
			Если НайденныеСтроки.Количество() > 0 Тогда
				ЗначениеДтКт = СтрокаПравила.ДтКт;
			Иначе
				ЗначениеДтКт = Перечисления.бит_ВидыСоответствия.Дебет;	
			КонецЕсли; 
		КонецЕсли; 
		
		Если ЗначениеДтКт = ВидСоответствия 
		 ИЛИ ЗначениеДтКт = Перечисления.бит_ВидыСоответствия.ДебетКредит Тогда
			
			ТекстПоСтроке = ГенерироватьКодПоСтрокеПравил(СтрокаПравила,КолонкиПравил,ТаблицаКолонки,УчитыватьКорреспонденцию,ДтКт);
			Если ДобавлятьМаркеры Тогда
				ТекстОтладка = СформироватьМаркерОтладки("П",СтрокаПравила.ИД);
			Иначе
				ТекстОтладка = "";
			КонецЕсли; 
			Если НЕ ПустаяСтрока(ТекстПоСтроке) Тогда
				
				НовыйКод = НовыйКод + ТекстОтладка + ?(Счетчик = 0, "Если ", "ИначеЕсли ");						
				НовыйКод = НовыйКод + ТекстПоСтроке;
		        Счетчик  = Счетчик + 1;
			Иначе
				Продолжить;
			КонецЕсли; 
		КонецЕсли;	 
		
		ТекстКодВложенный = ГенерироватьКодПоУровню(СтрокаПравила,КолонкиПравил,ТаблицаКолонки,УчитыватьКорреспонденцию,ДтКт,ДобавлятьМаркеры);
		
		СдвинутьКодПоУровню(ТекстКодВложенный,СтрокаПравила.Уровень()+1);
		
		НовыйКод = НовыйКод+ТекстКодВложенный;
		
	КонецЦикла; // По строкам таблицы правил

	Если НЕ ПустаяСтрока(НовыйКод) Тогда
		НовыйКод = НовыйКод + "КонецЕсли;" + Символы.ПС;
	КонецЕсли; 	
	
	Возврат НовыйКод;

КонецФункции // ГенерироватьКодПоУровню()

// Функция формирует маркер, используемый для поиска ошибок при отладке.
// 
// Параметры:
//  ВидСтроки  - Строка
//  ИДСтроки   - Строка
// 
// Возвращаемое значение:
//   СтрМаркер   - Строка
// 
Функция СформироватьМаркерОтладки(ВидСтроки,ИДСтроки)

	СтрМаркер = "// #Маркер{"+Строка(Ссылка.УникальныйИдентификатор())+"|"+ВидСтроки+"|"+ИДСтроки+"}"+Символы.ПС;

	Возврат СтрМаркер;
	
КонецФункции // СформироватьМаркерОтладки()

// Процедура сдвигает код вправо в зависимости от уровня правила.
// 
// Параметры:
//  ТекстКода  - Строка
//  Уровень    - Число
// 
Процедура СдвинутьКодПоУровню(ТекстКода,Уровень)

	Если Уровень<=0 Тогда
	
		Возврат;
	
	КонецЕсли; 
	
	Если ПустаяСтрока(ТекстКода) Тогда
	
		Возврат;
	
	КонецЕсли; 
	
	СтрокаСдвига = "";
	Для й=1 По Уровень Цикл
	
		СтрокаСдвига = СтрокаСдвига+Символы.Таб;
	
	КонецЦикла; 
    СтрокаСдвига = СтрокаСдвига;
	
	ТекстКода = СтрЗаменить(ТекстКода,Символы.ПС,Символы.ПС+СтрокаСдвига);
	ТекстКода = СтрокаСдвига+ТекстКода;
	ТекстКода = ТекстКода+Символы.ПС;
	
КонецПроцедуры // СдвинутьКодПоУровню()

// Функция формирует код установки дополнительных данных по колонкам типа ДополнительныеДанные.
// 
// Параметры:
//  СтрокаПравила     - СтрокаТаблицыЗначений.
//  КолонкаНастройки  - КолонкаТаблицыЗначений.
//  ЗначениеКолонки   - Произвольный.
//  ИмяКолонки        - Строка.
// 
// Возвращаемое значение:
//   ТекстРезультат     - Строка
// 
Функция СформироватьКодУстановкиДополнительныхДанных(СтрокаПравила,КолонкаНастройки,ЗначениеКолонки,ИмяКолонки,УчитыватьКорреспонденцию,ДтКт)

	Если ЗначениеКолонки = Ложь Тогда
		// Не нужно устанавливать, т.к. это значение типа по умолчанию.
		ТекстРезультат = "";
	Иначе	
		Если НЕ УчитыватьКорреспонденцию И Найти(ИмяКолонки,"ДополнительноеПоле_Счет") Тогда
			// ДополнительноеПоле_СчетДт, ДополнительноеПоле_СчетКт
			ИмяКлючаДополнительныеДанные = ИмяКолонки+ДтКт;
		Иначе   
			ИмяКлючаДополнительныеДанные = ИмяКолонки;
		КонецЕсли; 
		Шаблон = Символы.Таб + "ДополнительныеДанные.Вставить(""%1"",%2);" + Символы.ПС;
		ТекстРезультат = СтрШаблон(Шаблон, ИмяКлючаДополнительныеДанные, 
					   		СформироватьПредставлениеЗначения(ЗначениеКолонки,СтрокаПравила.ИД,ИмяКолонки));
	КонецЕсли; 

	Возврат ТекстРезультат;				
					
КонецФункции

// Функция формирует код установки значений по колонкам типа РеквизитПриемника.
// 
// Параметры:
//  СтрокаПравила     - СтрокаТаблицыЗначений.
//  КолонкаНастройки  - КолонкаТаблицыЗначений.
//  ЗначениеКолонки   - Произвольный.
//  ИмяКолонки        - Строка.
//  ДтКт              - Строка.
// 
// Возвращаемое значение:
//   ТекстРезультат     - Строка.
// 
Функция СформироватьКодУстановкиЗначенийПоКолонке(СтрокаПравила,КолонкаНастройки,ЗначениеКолонки,ИмяКолонки,ТаблицаКолонки,УчитыватьКорреспонденцию,ДтКт)

	ТекстРезультат = "";
	
	Если ТипЗнч(ЗначениеКолонки) = Тип("Строка") И СтрНайти(ЗначениеКолонки, "#С.") > 0 Тогда
		// Вызов процедуры заполнения по соответствиям.
		МассивВрем = бит_МеханизмТрансляции.РазобратьСтрокуСРазделителями(ЗначениеКолонки, ".");
		Если МассивВрем.Количество() > 1 Тогда
			ИмяСоответствия = МассивВрем[1];
			ТекстВызов = "ЗаполнитьПоСоответствию(ЗаписьИсточник, ЗаписьПриемник, СтруктураПараметров.ПараметрыАвтозаполнения, ВидыРегистров, ""%ИмяСоответствия%"");";
			ТекстВызов = СтрЗаменить(ТекстВызов, "%ИмяСоответствия%", ИмяСоответствия);
			ТекстРезультат = ТекстРезультат + Символы.Таб + ТекстВызов;
		КонецЕсли; 
	Иначе	
		
		Если КолонкаНастройки.ИмяРеквизита = "ПроизвольныйКод" Тогда
			ТекстРезультат = ТекстРезультат+Символы.Таб+ЗначениеКолонки;
		ИначеЕсли СтрСравнить(КолонкаНастройки.ИмяРеквизита, "СторнируемаяПроводка") = 0 Тогда
			// Уникальный неуниверсальный случай для РБ.бит_Дополнительный_2.
			// Значение = ЛОЖЬ - игнорируется.
			Если ТипЗнч(ЗначениеКолонки) = Тип("Булево") И ЗначениеКолонки Тогда
				ТекстРезультат = ТекстРезультат 
				+ Символы.Таб + "ЗаписьПриемник.СторнируемаяПроводка = Истина;" + Символы.ПС;
			КонецЕсли; 
		ИначеЕсли НЕ КолонкаНастройки.ЭтоСубконто Тогда
			
			// Заполнение значения 
			ТекстРезультат = ТекстРезультат
			+ Символы.Таб 
			+ "ЗаписьПриемник."
			+ КолонкаНастройки.ИмяРеквизита
			+ ?(КолонкаНастройки.НеБалансовый,ДтКт,"")
			+ " = "
			+ СформироватьПредставлениеЗначения(ЗначениеКолонки,СтрокаПравила.ИД,ИмяКолонки,ДтКт)
			+ ";"
			+ Символы.ПС;					
				
		Иначе
			
			Если НЕ УчитыватьКорреспонденцию Тогда
				СтрДтКт = ДтКт;
			    ИмяКолонкиИмяВида = Приемник.ИмяОбъекта + "_ИмяВидаСубконто" + Прав(КолонкаНастройки.ИмяРеквизита,1);			
			Иначе	
				СтрДтКт = Лев(Прав(КолонкаНастройки.ИмяРеквизита,3),2);
			    ИмяКолонкиИмяВида = Приемник.ИмяОбъекта + "_ИмяВидаСубконто" + СтрДтКт + Прав(КолонкаНастройки.ИмяРеквизита,1);			
			КонецЕсли; 
			
			КолонкаИмяВидаСубконто = ТаблицаКолонки.Найти(ИмяКолонкиИмяВида,"ИмяКолонки");
			Если КолонкаИмяВидаСубконто = Неопределено 
				ИЛИ НЕ ЗначениеЗаполнено(СтрокаПравила[КолонкаИмяВидаСубконто.ИмяКолонки]) Тогда
				ИмяВидаСубконто = Прав(КолонкаНастройки.ИмяРеквизита,1);
			Иначе	
				ИмяВидаСубконто = """"+СтрокаПравила[КолонкаИмяВидаСубконто.ИмяКолонки]+"""";
			КонецЕсли; 
			
			СтрСчет = "ЗаписьПриемник.Счет"+?(КолонкаНастройки.НеБалансовый,СтрДтКт,"");
			СтрВидыСубконто = "ЗаписьПриемник.Субконто"+?(КолонкаНастройки.НеБалансовый,СтрДтКт,"");
			
			 ТекстРезультат = ТекстРезультат
							+ Символы.Таб
							+ "УстановитьСубконто("+СтрСчет
							+ ","
							+ СтрВидыСубконто
							+ ","
							+ ИмяВидаСубконто
							+ ","
							+ СформироватьПредставлениеЗначения(ЗначениеКолонки,СтрокаПравила.ИД,ИмяКолонки,ДтКт)
							+");"
							+Символы.ПС;
							
		 КонецЕсли;
	КонецЕсли; 

	Возврат ТекстРезультат;
					
КонецФункции // СформироватьКодУстановкиУсловияПоКолонке()

// Функция формирует код условия по колонкам типа РеквизитИсточника.
// 
// Параметры:
//  СтрокаПравила     - СтрокаТаблицыЗначений.
//  КолонкаНастройки  - КолонкаТаблицыЗначений.
//  ЗначениеКолонки   - Произвольный.
//  ИмяКолонки        - Строка
//  УчитыватьКорреспонденцию - Булево.
//  ДтКт              - Строка.
// 
// Возвращаемое значение:
//   ТекстУсловие     - Строка.
// 
Функция СформироватьКодУсловияПоКолонке(СтрокаПравила,КолонкаНастройки,ЗначениеКолонки,ИмяКолонки,УчитыватьКорреспонденцию,ДтКт)

	ТекстУсловие = "";
	
	Если КолонкаНастройки.ЭтоСубконто Тогда
		Если НЕ УчитыватьКорреспонденцию Тогда
			ТекстУсловие = ТекстУсловие+" ЗначениеСубконто(ЗаписьИсточник,"""+ДтКт+""","+Прав(КолонкаНастройки.ИмяРеквизита,1)+")";
		Иначе	
			ТекстУсловие = ТекстУсловие+" ЗначениеСубконто(ЗаписьИсточник,"""+Лев(Прав(КолонкаНастройки.ИмяРеквизита,3),2)+""","+Прав(КолонкаНастройки.ИмяРеквизита,1)+")";
		КонецЕсли; 
	Иначе	
		ТекстУсловие = ТекстУсловие+" ЗаписьИсточник."+КолонкаНастройки.ИмяРеквизита;
		Если КолонкаНастройки.НеБалансовый Тогда
			ТекстУсловие = ТекстУсловие+ДтКт;
		КонецЕсли; 					  
	КонецЕсли; 
	ТекстУсловие = ТекстУсловие+" = "+СформироватьПредставлениеЗначения(ЗначениеКолонки,СтрокаПравила.ИД,ИмяКолонки,ДтКт);
	
	Возврат ТекстУсловие;

КонецФункции // СформироватьКодУсловия()

// Функция формирует код по настройке произвольных условий.
// 
// Параметры
//  СтрокаПравила   - СтрокаТаблицыЗначений.
//  КолонкиПравила  - КолонкиТаблицыЗначений.
//  ДтКт            - Строка - "Дт","Кт".
// 
// Возвращаемое значение:
//   ТекстПроизвольноеУсловие   - Строка.
// 
Функция СформироватьКодПроизвольногоУсловия(СтрокаПравила,КолонкиПравила,УчитыватьКорреспонденцию,вхДтКт)

	ДтКт    = ?(ЗначениеЗаполнено(вхДтКт), вхДтКт, "Дт");
	ДтКтКор = ?(ДтКт="Дт","Кт","Дт");
	
	ТекстПроизвольноеУсловие = "";
	
	// Определим количество произвольных условий.
	КоличествоПроизвольныхУсловий = 0;
	Пока ИСТИНА Цикл
		КолонкаУсловие = КолонкиПравила.Найти("Условие"+(КоличествоПроизвольныхУсловий+1));
		Если КолонкаУсловие = Неопределено Тогда
			Прервать;
		Иначе
			КоличествоПроизвольныхУсловий = КоличествоПроизвольныхУсловий+1;
		КонецЕсли; 
	КонецЦикла;
	
	// Сформируем текст произвольного условия
	ОбъединениеСПоследующим = Неопределено;
	
	Для Индекс = 1 По КоличествоПроизвольныхУсловий Цикл
	
		РезСтруктура = Справочники.бит_ПравилаТрансляции.НайтиПоляУсловия(СтрокаПравила,КолонкиПравила,Индекс);
		Если НЕ ЗначениеЗаполнено(РезСтруктура.Условие) Тогда
			Продолжить;
		КонецЕсли; 
		
		Если НЕ ПустаяСтрока(ТекстПроизвольноеУсловие) Тогда
			
			ТекстПроизвольноеУсловие = ТекстПроизвольноеУсловие
			                          + "
									  	|	" + ?(ЗначениеЗаполнено(ОбъединениеСПоследующим),ОбъединениеСПоследующим, "И") + " ";
		
		КонецЕсли; 
		
		РежимПроверкиЗаполнения = СтрНайти(РезСтруктура.Условие,"ЗначениеЗаполнено(") > 0;
				
		// ЛЕВОЕ ЗНАЧЕНИЕ УСЛОВИЯ
		Если РежимПроверкиЗаполнения Тогда
			ПустьКДанным = СтрЗаменить(РезСтруктура.Условие, "ЗначениеЗаполнено(", "");
			ПустьКДанным = Лев(ПустьКДанным, СтрДлина(ПустьКДанным) - 1);
		Иначе
			ПустьКДанным = РезСтруктура.Условие;
		КонецЕсли; 
		
		Если ТипЗнч(РезСтруктура.Значение) = Тип("СправочникСсылка.бит_ОбъектыСистемы")  Тогда
			ЛевоеЗначение  = "МетаданныеРегистратора.Имя";
		Иначе	
			ЛевоеЗначение = СформироватьПредставлениеЗначения(ПустьКДанным, СтрокаПравила.ИД, "Значение" + Индекс, ДтКт);
		КонецЕсли; 
		
		Если РежимПроверкиЗаполнения Тогда
			ЛевоеЗначение = СтрШаблон("ЗначениеЗаполнено(%1)", ЛевоеЗначение);
		КонецЕсли; 
				
		// ПРАВОЕ ЗНАЧЕНИЕ УСЛОВИЯ
		Если ТипЗнч(РезСтруктура.Значение) = Тип("СправочникСсылка.бит_ОбъектыСистемы") Тогда
			ПравоеЗначение = СтрШаблон("""%1""", РезСтруктура.Значение.ИмяОбъекта);
		Иначе							
			ПравоеЗначение = СформироватьПредставлениеЗначения(РезСтруктура.Значение,СтрокаПравила.ИД,"Значение" + Индекс, ДтКт);
		КонецЕсли; 
		
		// ВИД СРАВНЕНИЯ
		СтрНЕ                = СформироватьСтрокуНЕ(РезСтруктура.ВидСравнения);
		СтрВидСравнения      = СформироватьПредставлениеВидаСравнения(РезСтруктура.ВидСравнения);

		ЭтоУсловиеНаГруппу = ЭтоУсловиеНаГруппу(РезСтруктура.ВидСравнения);
		ЭтоСравнениеСтрок  = ЭтоСравнениеСтрок(РезСтруктура.ВидСравнения);
		
		СтрПоследняяСкобка = ?(ЭтоУсловиеНаГруппу ИЛИ ЭтоСравнениеСтрок,")","");
		
		// Проверка на допустимость проверки принадлежности элементу.
		Если ЭтоУсловиеНаГруппу Тогда
			Если НЕ (бит_ОбщегоНазначения.ЗначениеПринадлежитКоллекцииМетаданных("Справочники",РезСтруктура.Значение) 
				     ИЛИ бит_ОбщегоНазначения.ЗначениеПринадлежитКоллекцииМетаданных("ПланыСчетов",РезСтруктура.Значение)
					 ИЛИ бит_ОбщегоНазначения.ЗначениеПринадлежитКоллекцииМетаданных("ПланыВидовХарактеристик",РезСтруктура.Значение)) Тогда
				Продолжить;
			КонецЕсли; 
		КонецЕсли; 
		
		// СБОРКА ТЕКСТА УСЛОВИЯ: СтрНЕ СтрУсловие СтрВидСравнения СтрЗначение СтрПоследняяСкобка.
		Шаблон = "%1 %2 %3 %4 %5";
		ТекстПроизвольноеУсловие = ТекстПроизвольноеУсловие 
								 + СтрШаблон(Шаблон, СтрНЕ, ЛевоеЗначение, СтрВидСравнения, ПравоеЗначение, СтрПоследняяСкобка);

		ОбъединениеСПоследующим = РезСтруктура.ОбъединениеСПоследующим;	

	КонецЦикла; // По количеству произвольных условий

	Возврат ТекстПроизвольноеУсловие;

КонецФункции // СформироватьКодПроизвольногоУсловия()

// Функция формирует строку отрицания условия в зависимости от вида сравнения.
// 
// Параметры:
//  ВидСравнения  - Перечисления.бит_ВидыСравненияТрансляции.
// 
// Возвращаемое значение:
//   СтрНЕ   - Строка.
// 
Функция СформироватьСтрокуНЕ(ВидСравнения)

	Если ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.ВГруппе Тогда
		СтрНЕ = "ОбъектПодчинен(";	
	ИначеЕсли ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.НЕВГруппе Тогда
		СтрНЕ = "НЕ ОбъектПодчинен(";	
	ИначеЕсли ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.Содержит Тогда 
		СтрНЕ = "Содержит(";
	ИначеЕсли ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.НеСодержит Тогда 
		СтрНЕ = "НЕ Содержит(";
	ИначеЕсли ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.НачинаетсяС Тогда 
		СтрНЕ = "НачинаетсяС(";
	ИначеЕсли ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.НеНачинаетсяС Тогда 
		СтрНЕ = "НЕ НачинаетсяС(";
	Иначе	
		СтрНЕ = "";	
	КонецЕсли; 
	
	Возврат СтрНЕ;

КонецФункции // СформироватьСтрокуНЕ()

Функция ЭтоСравнениеСтрок(ВидСравнения)

	ЭтоСравнениеСтрок = Ложь;
	
	Если ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.Содержит 
	 ИЛИ ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.НеСодержит
	 ИЛИ ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.НачинаетсяС
	 ИЛИ ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.НеНачинаетсяС Тогда
	 
	 	ЭтоСравнениеСтрок = Истина;
	КонецЕсли; 

	Возврат ЭтоСравнениеСтрок;
	
КонецФункции
 
// Функция определяет, задает ли данные вид сравнения условие на вхождение в группу или нет.
// 
// Параметры:
//  ВидСравнения  - Перечисления.бит_ВидыСравненияТрансляции.
// 
// Возвращаемое значение:
//   флЭтоУсловиеНаГруппу   - Булево.
// 
Функция ЭтоУсловиеНаГруппу(ВидСравнения)

	ЭтоУсловиеНаГруппу = Ложь;
	
	Если ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.ВГруппе 
	 ИЛИ ВидСравнения = Перечисления.бит_ВидыСравненияТрансляции.НЕВГруппе Тогда
	
		ЭтоУсловиеНаГруппу = Истина;
	КонецЕсли; 

	Возврат ЭтоУсловиеНаГруппу;
	
КонецФункции // ЭтоУсловиеНаГруппу()

// Функция формирует текстовое представление вида сравнения.
// 
// Параметры:
//  ВидСравнения  - Перечисления.бит_ВидыСравненияТрансляции.
// 
// Возвращаемое значение:
//  СтрВидСравнения   - Строка
// 
Функция СформироватьПредставлениеВидаСравнения(ВидСравнения)

	Если ЭтоУсловиеНаГруппу(ВидСравнения) Тогда
		СтрВидСравнения = ",";
	ИначеЕсли ЭтоСравнениеСтрок(ВидСравнения) Тогда
		СтрВидСравнения = ",";
	Иначе	
		Если ЗначениеЗаполнено(ВидСравнения) Тогда
			СтрВидСравнения = " " + Строка(ВидСравнения) + " ";
		Иначе	
			СтрВидСравнения = " = ";
		КонецЕсли; 
	КонецЕсли; 

	Возврат СтрВидСравнения;
	
КонецФункции // СформироватьПредставлениеВидаСравнения()

// Функция формирует строковое представление значения для добавления в код.
// 
// Параметры:
//  ЗначениеКолонки  - Произвольный.
//  ИДСтроки         - Строка.
//  ИмяКолонки       - Строка.
// 
// Возвращаемое значение:
//   ПредставлениеЗначения   - Строка.
// 
Функция СформироватьПредставлениеЗначения(Знач ЗначениеКолонки, ИДСтроки, ИмяКолонки, вхДтКт = "Дт")

	// NB: см в 3.1.34.4. 
	
	ДтКт 				  = ?(ПустаяСтрока(вхДтКт), "Дт", вхДтКт);
	ДтКтКор 			  = ?(ДтКт = "Дт","Кт","Дт");
	ПредставлениеЗначения = "";
		
	Если ТипЗнч(ЗначениеКолонки) = Тип("Строка") Тогда
		
		// Некоторые функции получения данных по ссылке умеют работать с подсистемой "Сведения" из БСП.
		ПолучениеДопРеквизитовОбеспечено = Ложь;
		
		Если СтрНайти(ЗначениеКолонки,"#А.") > 0 Тогда
			
			Шаблон 	   			  = "ИзвлечьЗначениеАналитики(""%1"", ДополнительныеАналитики)";
			ПутьКДанным 		  = ПутьКДаннымИзСтрокиСДополнениями(ЗначениеКолонки, "#А");
			ПредставлениеЗначения = СтрШаблон(Шаблон, ПутьКДанным);
			
		ИначеЕсли СтрНайти(ЗначениеКолонки,"#Р.") > 0 Тогда
			
			// Пример: "#Р.АвансовыйОтчет.ДополнительноеСвойство_Проект".
			ПолучениеДопРеквизитовОбеспечено = Истина;
			Шаблон 	   		      = "ЗначениеРеквизита(Источник, ""Регистратор.%1"")"; 
			ПутьКДанным 		  = ПутьКДаннымИзСтрокиСДополнениями(ЗначениеКолонки,"#Р", ПолучениеДопРеквизитовОбеспечено);
			ПредставлениеЗначения = СтрШаблон(Шаблон, ПутьКДанным);
		ИначеЕсли СтрНайти(ЗначениеКолонки,"Субконто") > 0 
			//ОКЕЙ Бублик А.А.(СофтЛаб) Начало 2020-10-09 (#3905)
			И(СтрНайти(ЗначениеКолонки,"Субконто.") > 0
				Или СтрНайти(ЗначениеКолонки,"СубконтоКор") > 0
				Или СтрНайти(ЗначениеКолонки,"СубконтоДт")> 0
				Или СтрНайти(ЗначениеКолонки,"СубконтоКт") > 0)
			//ОКЕЙ Бублик А.А.(СофтЛаб) Конец 2020-10-09 (#3905)
			Тогда	
			
			// Обработка субконто.
			// Для обратной совместимости с предыдущими версиями привил ...
			СоставЗначения = СтрРазделить(ЗначениеКолонки, ".");
			Если СтрНачинаетсяС(СоставЗначения[0], "Субконто") Тогда
				ИсточникДанных = "ЗаписьИсточник";
			ИначеЕсли СтрНачинаетсяС(СоставЗначения[0], "ЗаписьИсточник") ИЛИ СтрНачинаетсяС(СоставЗначения[0], "ЗаписьПриемник") Тогда	
				ИсточникДанных = СоставЗначения[0];
				СоставЗначения.Удалить(0);
			Иначе
				ВызватьИсключение СтрШаблон(Нстр("ru = 'Обновление исполняемого кода: "
													+ "выражение ""%1"" не соответствует ожидаемому.'"), ЗначениеКолонки);
			КонецЕсли; 
			Выражение = СтрСоединить(СоставЗначения, ".");
			
			Если СтрНайти(Выражение,"Субконто.") > 0 Тогда	
				
				// Пример: "ЗаписьИсточник.Субконто.РаботникиОрганизаций.ДополнительныйРеквизит_Должность (Физические лица)".
				ПолучениеДопРеквизитовОбеспечено = Истина;
				Шаблон 				  = "ЗначениеСубконто(%1,""%2"",""Субконто.%3"")";
				ПутьКДанным 		  = ПутьКДаннымИзСтрокиСДополнениями(Выражение, "Субконто", ПолучениеДопРеквизитовОбеспечено);
				ПредставлениеЗначения = СтрШаблон(Шаблон, ИсточникДанных, ДтКт, ПутьКДанным);
				
			ИначеЕсли СтрНайти(Выражение,"СубконтоКор") > 0 Тогда 
				
				// Пример: "ЗаписьИсточник.СубконтоКор.РаботникиОрганизаций.ДополнительныйРеквизит_Должность (Физические лица)".	
				ПолучениеДопРеквизитовОбеспечено = Истина;
				Шаблон 				  = "ЗначениеСубконто(%1,""%2"",""Субконто.%3"")";
				ПутьКДанным 		  = ПутьКДаннымИзСтрокиСДополнениями(Выражение, "СубконтоКор", ПолучениеДопРеквизитовОбеспечено);
				ПредставлениеЗначения = СтрШаблон(Шаблон, ИсточникДанных, ДтКтКор, ПутьКДанным);
				
			ИначеЕсли СтрНайти(Выражение,"СубконтоДт") > 0 Тогда	
				
				// Пример: "ЗаписьИсточник.СубконтоДт.РаботникиОрганизаций.ДополнительныйРеквизит_Должность (Физические лица)".
				ПолучениеДопРеквизитовОбеспечено = Истина;
				Шаблон 				  = "ЗначениеСубконто(%1,""%2"",""Субконто.%3"")";
				ПутьКДанным 		  = ПутьКДаннымИзСтрокиСДополнениями(Выражение, "СубконтоДт", ПолучениеДопРеквизитовОбеспечено);
				ПредставлениеЗначения = СтрШаблон(Шаблон, ИсточникДанных, "Дт", ПутьКДанным);
				
			ИначеЕсли СтрНайти(Выражение,"СубконтоКт") > 0 Тогда	
				
				// Пример: "ЗаписьИсточник.СубконтоКт.РаботникиОрганизаций.ДополнительныйРеквизит_Должность (Физические лица)".
				ПолучениеДопРеквизитовОбеспечено = Истина;
				Шаблон 				  = "ЗначениеСубконто(%1,""%2"",""Субконто.%3"")";
				ПутьКДанным 		  = ПутьКДаннымИзСтрокиСДополнениями(Выражение, "СубконтоКт", ПолучениеДопРеквизитовОбеспечено);
				ПредставлениеЗначения = СтрШаблон(Шаблон, ИсточникДанных, "Кт", ПутьКДанным);
			КонецЕсли;	
			
		ИначеЕсли СтрНайти(ЗначениеКолонки, "[ДтКт]") > 0 Тогда	 
			
			ПредставлениеЗначения = СтрЗаменить(ЗначениеКолонки, "[ДтКт]", ДтКт);
	
		ИначеЕсли СтрНайти(ЗначениеКолонки, "[Кор]") > 0 Тогда	 
			
			ПредставлениеЗначения = СтрЗаменить(ЗначениеКолонки, "[Кор]", ДтКтКор);
						
		ИначеЕсли СтрНайти(ЗначениеКолонки, "ЗаписьИсточник.") > 0 Тогда	 
			
			Шаблон 				  = "ЗаписьИсточник.%1";
			ПутьКДанным 		  = ПутьКДаннымИзСтрокиСДополнениями(ЗначениеКолонки, "ЗаписьИсточник");
			ПредставлениеЗначения = СтрШаблон(Шаблон, ПутьКДанным);
			
		ИначеЕсли СтрНайти(ЗначениеКолонки, "ЗаписьПриемник.") > 0 Тогда	 
			
			Шаблон 				  = "ЗаписьПриемник.%1";
			ПутьКДанным 		  = ПутьКДаннымИзСтрокиСДополнениями(ЗначениеКолонки, "ЗаписьПриемник");
			ПредставлениеЗначения = СтрШаблон(Шаблон, ПутьКДанным);
			
		ИначеЕсли СтрНайти(ЗначениеКолонки, "Регистратор.") > 0 Тогда
			
			// Пример: "Регистратор.АвансовыйОтчет.ДополнительноеСвойство_Проект". 
			ПолучениеДопРеквизитовОбеспечено = Истина;
			Шаблон 				  = "ЗначениеРеквизита(Источник,""%1"")";
			ПредставлениеЗначения = СтрШаблон(Шаблон, ЗначениеКолонки);
			
		Иначе
			
			ПредставлениеЗначения = СтрШаблон("""%1""", ЗначениеКолонки);
			
		КонецЕсли; 
		
		// Значение дополнительных реквизитов или сведений.
		Если (СтрНайти(ЗначениеКолонки, "ДополнительныйРеквизит_") > 0 
		 ИЛИ СтрНайти(ЗначениеКолонки, "ДополнительноеСвойство_") > 0) 
		   И НЕ ПолучениеДопРеквизитовОбеспечено Тогда
			
			Строки     = бит_СтрокиКлиентСервер.РазобратьСтрокуСРазделителями(ЗначениеКолонки, ".");
			ИндексПоля = ИндексПоляДополнительныхРеквизитовИСвойств(Строки);
			СтрокиДоп  = бит_СтрокиКлиентСервер.РазобратьСтрокуСРазделителями(Строки[ИндексПоля], "_");
			
			Шаблон = "ЗначениеДопРеквизита(%1,""%2"", ""%3"")";
			ПредставлениеЗначения = СтрШаблон(Шаблон, ПредставлениеЗначения, СтрокиДоп[0], СтрокиДоп[1]);  
			
		КонецЕсли; 
		
	ИначеЕсли ТипЗнч(ЗначениеКолонки) = Тип("Дата") Тогда
		
		ПредставлениеЗначения = "Дата('"+Формат(ЗначениеКолонки,"ДФ=yyyyMMdd")+"')";
		
	ИначеЕсли ТипЗнч(ЗначениеКолонки) = Тип("Число") Тогда
		
		ПредставлениеЗначения = Формат(ЗначениеКолонки,"ЧРД=.; ЧГ=99999");
		
	ИначеЕсли ТипЗнч(ЗначениеКолонки) = Тип("Булево") Тогда
		
		ПредставлениеЗначения = Формат(ЗначениеКолонки,"БЛ=ЛОЖЬ; БИ=ИСТИНА");
		
	ИначеЕсли ЗначениеКолонки = НЕОПРЕДЕЛЕНО Тогда	
		
		ПредставлениеЗначения = "НЕОПРЕДЕЛЕНО";
		
	ИначеЕсли бит_ОбщегоНазначения.ЗначениеПринадлежитКоллекцииМетаданных("Перечисления",ЗначениеКолонки)	Тогда
		
		Если ЗначениеКолонки.Метаданные().Имя = "бит_ВидДвиженияНакопления" Тогда
			ПредставлениеЗначения = "ВидДвиженияНакопления."
			+бит_ОбщегоНазначения.ПолучитьИмяЗначенияПеречисления(Перечисления[ЗначениеКолонки.Метаданные().Имя],ЗначениеКолонки);
		Иначе	
			ПредставлениеЗначения = "Перечисления."
			+ЗначениеКолонки.Метаданные().Имя
			+"."
			+бит_ОбщегоНазначения.ПолучитьИмяЗначенияПеречисления(Перечисления[ЗначениеКолонки.Метаданные().Имя],ЗначениеКолонки);
		КонецЕсли; 
		
		
	ИначеЕсли бит_ОбщегоНазначения.ЗначениеПринадлежитКоллекцииМетаданных("ПланыСчетов",ЗначениеКолонки)	Тогда
		
		ПредставлениеЗначения = ДобавитьЗначениеПоКоллекцииСПредопределенными("ПланыСчетов",ЗначениеКолонки,ИДСтроки,ИмяКолонки);
		
	ИначеЕсли бит_ОбщегоНазначения.ЗначениеПринадлежитКоллекцииМетаданных("Справочники",ЗначениеКолонки) Тогда
		
		ПредставлениеЗначения = ДобавитьЗначениеПоКоллекцииСПредопределенными("Справочники",ЗначениеКолонки,ИДСтроки,ИмяКолонки);
		
	ИначеЕсли бит_ОбщегоНазначения.ЗначениеПринадлежитКоллекцииМетаданных("ПланыВидовХарактеристик",ЗначениеКолонки) Тогда
		
		ПредставлениеЗначения = ДобавитьЗначениеПоКоллекцииСПредопределенными("ПланыВидовХарактеристик",ЗначениеКолонки,ИДСтроки,ИмяКолонки);
		
	Иначе
		
		ПредставлениеЗначения = ДобавитьЗначениеРеквизита(ИДСтроки,ИмяКолонки);
		
	КонецЕсли; 
	
	Возврат ПредставлениеЗначения;
	
КонецФункции // СформироватьПредставлениеЗначения()

Функция ПутьКДаннымИзСтрокиСДополнениями(СтрокаСДополнениями, НачалоПути, ПолучениеДопРеквизитовОбеспечено = Ложь)

	ПутьКДанным = СтрокаСДополнениями;
	
	Строки = СтрРазделить(СтрокаСДополнениями, ".");
	Если Строки.Количество() <> 0 Тогда
		
		// Очистка от части пути к доп. реквизитам и свойствам.
		Если НЕ ПолучениеДопРеквизитовОбеспечено Тогда
			ИндексДопСвойств = ИндексПоляДополнительныхРеквизитовИСвойств(Строки);
			Если ИндексДопСвойств <> Неопределено Тогда
				Строки.Удалить(ИндексДопСвойств);
			КонецЕсли; 
		КонецЕсли; 
		
		// Формирование массива из частей пути к данным.
		НачальныйИндекс = Строки.Найти(НачалоПути); 
		Если НачальныйИндекс <> Неопределено И Строки.ВГраница() >= НачальныйИндекс + 1 Тогда
			
			Поля = Новый Массив(); 
			Для Индекс = НачальныйИндекс + 1 По Строки.ВГраница() Цикл
				Поля.Добавить(Строки[Индекс]);
			КонецЦикла; 
			ПутьКДанным = СтрСоединить(Поля, ".");
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат ПутьКДанным;
	
КонецФункции // ПолеДанныхИзПути()

Функция ИндексПоляДополнительныхРеквизитовИСвойств(Строки)
	
	ИндексПоля = Неопределено;
	
	Для Индекс = 0 По Строки.ВГраница() Цикл
		СтрокаСДополнениями = Строки.Получить(Индекс);
		Если СтрНайти(СтрокаСДополнениями, "ДополнительныйРеквизит_") <> 0 
		 ИЛИ СтрНайти(СтрокаСДополнениями, "ДополнительноеСвойство_") <> 0 Тогда
		 
		 	// Поиск завершен.
			ИндексПоля = Индекс;
			Прервать;
	 	КонецЕсли; 
	КонецЦикла; 
	
	Возврат ИндексПоля;
	
КонецФункции // ПоляДополнительныхРеквизитовИСведений()
  
// Функция формирует строковое представление значения для добавления в код. 
// Для преодпределенных значений формируется обращение по имени. 
// Для НЕ преодпределенных - по ИД строки и имени колонки из Кэша.
// 
// Параметры:
//  ИмяКоллекции    - Строка.
//  ЗначениеКолонки - Произвольный.
//  ИДСтроки        - Строка.
//  ИмяКолонки      - Строка.
// 
// Возвращаемое значение:
//   ПредставлениеЗначения   - Строка.
// 
Функция ДобавитьЗначениеПоКоллекцииСПредопределенными(ИмяКоллекции,ЗначениеКолонки,ИДСтроки,ИмяКолонки)

	ПредставлениеЗначения = "";
	
	Менеджер = бит_ОбщегоНазначения.ПолучитьМенеджер(ИмяКоллекции); 
	
	Если Менеджер <> Неопределено Тогда
		
		Если ЗначениеКолонки.Предопределенный Тогда
			ИмяОбъекта = ЗначениеКолонки.Метаданные().Имя;
			ИмяПредопределенного = Менеджер[ИмяОбъекта].ПолучитьИмяПредопределенного(ЗначениеКолонки);
			ПредставлениеЗначения = ИмяКоллекции+"."+ИмяОбъекта+"."+ИмяПредопределенного;
		Иначе	
			ПредставлениеЗначения = ДобавитьЗначениеРеквизита(ИДСтроки,ИмяКолонки);
		КонецЕсли; 
		
	КонецЕсли; 

	Возврат ПредставлениеЗначения;
	
КонецФункции // ДобавитьЗначениеПоКоллекцииСПредопределенными()

// Функция формирует код для получения параметра по ИД.
// 
// Параметры:
//  ИДСтроки   - Строка
//  ИмяКолонки - Строка
// 
Функция ДобавитьЗначениеРеквизита(ИДСтроки,ИмяКолонки)
	
	ПредставлениеЗначения = "ЗначениеПараметра("""+ИдСтроки+""","""+ИмяКолонки+""", КэшРеквизитов"+")";
	
	Возврат ПредставлениеЗначения;
	
КонецФункции // ДобавитьЗначениеВСтек()

// Процедура - обработчик события "ПриКопировании".
// 
Процедура ПриКопировании(ОбъектКопирования)

	// Выполним замену ИД при копировании, чтобы не возникало проблем при совместном использовании правил.
	
	// Кэш для хранения ИД
	НовыеИД = Новый Соответствие;
	
	ТаблицаИерархии = ИерархияСтрок.Выгрузить();
	ТаблицаИерархии.Свернуть("ИД,ИДРодителя");
	
	ТаблицаЗначенияРеквизитов = ЗначенияРеквизитов.Выгрузить();
	ТаблицаЗначенияРеквизитов.Свернуть("ИД");
	
	// Создадим новые ИД
	Для каждого СтрокаТаблицы Из ТаблицаИерархии Цикл
		
		ДобавитьИД(СтрокаТаблицы.ИД,НовыеИД);
		
		Если  НЕ ПустаяСтрока(СтрокаТаблицы.ИДРодителя) Тогда
			
			ДобавитьИД(СтрокаТаблицы.ИдРодителя,НовыеИД);
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	Для каждого  СтрокаТаблицы Из ТаблицаЗначенияРеквизитов Цикл
		
		ДобавитьИД(СтрокаТаблицы.ИД,НовыеИД);
		
	КонецЦикла; 
	
	// Замена ИД
	Для каждого СтрокаТаблицы Из ИерархияСтрок Цикл
	
		НовИД = НовыеИД[СтрокаТаблицы.ИД];
		
		Если ЗначениеЗаполнено(НовИД) Тогда
		
			СтрокаТаблицы.ИД = НовИД;
		
		КонецЕсли; 
		
		Если НЕ ПустаяСтрока(СтрокаТаблицы.ИДРодителя) Тогда
		
			НовИД = НовыеИД[СтрокаТаблицы.ИДРодителя];
			
			Если ЗначениеЗаполнено(НовИД) Тогда
			
				СтрокаТаблицы.ИДРодителя = НовИД;
			
			КонецЕсли; 
		
		КонецЕсли; 
		
	КонецЦикла; // По табличной части ИерархияСтрок 
	
	Для каждого СтрокаТаблицы Из ЗначенияРеквизитов Цикл
		
		НовИД = НовыеИД[СтрокаТаблицы.ИД];
		
		Если ЗначениеЗаполнено(НовИД) Тогда
			
			СтрокаТаблицы.ИД = НовИД;
			
		КонецЕсли; 
		
	КонецЦикла; // По табличной части ЗначенияРеквизитов
	
КонецПроцедуры

// Процедура добавляет новый ИД в кэш. Используется при замене ИД при копировании.
// 
// Параметры:
//  ТекИД  - Строка
//  Кэш    - Соответствие
// 
Процедура ДобавитьИД(ТекИД,Кэш)

	НайденныйИД = Кэш[ТекИД];
	Если НайденныйИД = Неопределено Тогда
		
		НовИД = Строка(Новый УникальныйИдентификатор());
		Кэш.Вставить(ТекИД,НовИД);
		
	КонецЕсли; 

КонецПроцедуры // ДобавитьИД()

Процедура ЗаполнитьПоНастройке(ДанныеЗаполнения)

	РеквизитыНастройки = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ДанныеЗаполнения, "Источник, Приемник");	
	НастройкаПравилТрансляции = ДанныеЗаполнения;
	Источник = РеквизитыНастройки.Источник;
	Приемник = РеквизитыНастройки.Приемник;
	
КонецПроцедуры
 
#КонецОбласти

#КонецЕсли
