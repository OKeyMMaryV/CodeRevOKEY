
#Область ОбработчикиСобытийФормы

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	
	// Теперь необходимо позиционировать выделение на строку, соответствующую текущему значению.
	ПозиционироватьВыделение();
	// Элементы.ДеревоЗначений.ТекущаяСтрока 
	//     = ПолучитьВеткуДереваНаКлиенте("ФиксированноеЗначение").ПолучитьИдентификатор();
	
КонецПроцедуры

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	ОбработатьПараметрыОткрытияФормы();
	
	СоздатьХранилищеТиповДанных();
	
	ЗаполнитьДеревоПредопределенными();
	ЗаполнитьДеревоПоТекущемуШаблону();
	
	ДоступныеТипы = ПолучитьИзВременногоХранилища(ДоступныеТипыАдрес);
	
	// Ограничим тип поля ввода фиксированного значения.
	Если ДоступныеТипы <> Неопределено Тогда
		Элементы.ПолеФиксированноеЗначение.ОграничениеТипа = ДоступныеТипы;
		ПолеФиксированноеЗначение = ДоступныеТипы.ПривестиЗначение();		
		// Изменение кода. Начало. 05.06.2014{{
		Если ТипЗнч(ТекущееЗначение) = Тип("СписокЗначений") ИЛИ ВидСравнения = Перечисления.бит_ЛогическиеОператоры.ВСписке Тогда
		
			 Элементы.ПолеФиксированноеЗначение.ОграничениеТипа = Новый ОписаниеТипов("СписокЗначений");
			 Если ПолеФиксированноеЗначение = Неопределено Тогда
			 
			 	  ПолеФиксированноеЗначение = Новый СписокЗначений;
			 
			 КонецЕсли; 
		
		КонецЕсли; 
		// Изменение кода. Конец. 05.06.2014}}
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовШапкиФормы

&НаКлиенте
Процедура РежимПостроителяПроизвольногоВыраженияПриИзменении(Элемент)
	
	ДеревоЗначенийПриАктивизацииСтроки(Элементы.ДеревоЗначений);
	
	Если РежимПостроителяПроизвольногоВыражения Тогда
		Элементы.ГруппаСтраницы.ТекущаяСтраница = Элементы.СтраницаРеквизит;
		Элементы.НадписьСтрокаЗначения.ТолькоПросмотр = Ложь;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицыФормыДеревоЗначений

// Процедура - обработчик выбора строки в дереве занчений.
// 
&НаКлиенте
Процедура ДеревоЗначенийВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	
	Если РежимПостроителяПроизвольногоВыражения Тогда
		ПриВыбореЗначенияРежимПостроителя();
	Иначе	
		ПриВыбореЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Процедура - обработчик события "ПриАктивизацииСтроки" ДереваЗначений.
// 
&НаКлиенте
Процедура ДеревоЗначенийПриАктивизацииСтроки(Элемент)
	
	ДанныеСтроки = Элементы.ДеревоЗначений.ТекущиеДанные;
	
	Если не РежимПостроителяПроизвольногоВыражения Тогда
		
		НадписьСтрокаЗначения = ПолучитьПолноеИмяРеквизита(ДанныеСтроки);
		
		Если ДанныеСтроки.Тип = "ПользовательскаяФункция" Тогда
			
			ИмяФункции = ПолучитьПолноеИмяРеквизита(ДанныеСтроки);
			
			ПодчиненныеСтроки = ДанныеСтроки.ПолучитьЭлементы();
			
			// Дополним строку параметрами
			ИмяФункции = ИмяФункции + "(";		
			Для Каждого Параметр Из ПодчиненныеСтроки Цикл
				ИмяФункции = ИмяФункции + ", " + Строка(Параметр.Значение);
			КонецЦикла;
			ИмяФункции = ИмяФункции + ")";
			
			ИмяФункции = СтрЗаменить(ИмяФункции, "(,", "(");
			
			НадписьСтрокаЗначения = ИмяФункции;
			
		КонецЕсли;
		
		Если не ДанныеСтроки.Использование Тогда
			НадписьСтрокаЗначения = "<не используется для данного реквизита>";
		КонецЕсли;
		
		Элементы.НадписьСтрокаЗначения.ТолькоПросмотр = не ДанныеСтроки.Использование;
		
		Если ДанныеСтроки.Тип = "ФиксированноеЗначение" Тогда
			Элементы.ГруппаСтраницы.ТекущаяСтраница = Элементы.СтраницаФиксированноеЗначение;
		Иначе
			Элементы.ГруппаСтраницы.ТекущаяСтраница = Элементы.СтраницаРеквизит;
		КонецЕсли;
		
	Иначе
		
		Если НадписьСтрокаЗначения = "<не используется для данного реквизита>" Тогда
			НадписьСтрокаЗначения = "";
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура вызывается в тот момент, когда пользователь выбирает значение и возвращает
// выбранное значение реквизиту-владельцу формы.
// 
&НаКлиенте
Процедура ПриВыбореЗначения()
	
	// Проверим, какие данные содержатся в текущей строке и можно ли их выбирать.
	ТекущаяСтрока = Элементы.ДеревоЗначений.ТекущиеДанные;
	
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если (ТекущаяСтрока.Тип = "Реквизит" 
		  или ТекущаяСтрока.Тип = "ДопРеквизит" или
		  ТекущаяСтрока.Тип = "ДопАналитика") 
		  и ТекущаяСтрока.Использование Тогда
		
		Структура = Новый Структура("Значение, ПодчиненноеЗначение");
		Структура.Значение = ПолучитьПолноеИмяРеквизита(ТекущаяСтрока);
		
		ОгрТип = ПолучитьОписаниеИзХранилища(ТекущаяСтрока.ПолучитьИдентификатор());
		
		Если ОгрТип = Тип("ОписаниеТипов") Тогда
			Структура.ПодчиненноеЗначение = ОгрТип.ПривестиЗначение();
		КонецЕсли;
		
		Закрыть(Структура);
		
	КонецЕсли;
	
	Если ТекущаяСтрока.Тип = "ФиксированноеЗначение" Тогда
		
		Если ТипЗнч(ПолеФиксированноеЗначение) = Тип("Строка") и Найти(ПолеФиксированноеЗначение, "#") = 0 Тогда
			Закрыть("""" + ПолеФиксированноеЗначение + """");
		Иначе	
			Закрыть(ПолеФиксированноеЗначение);
		КонецЕсли;
				
	КонецЕсли;
	
	Если ТекущаяСтрока.Тип = "ПроизвольнаяСтрока" Тогда
		Закрыть("");
	КонецЕсли;
	
	Если ТекущаяСтрока.Тип = "ПользовательскаяФункция" Тогда
		
		ИмяФункции = ПолучитьПолноеИмяРеквизита(ТекущаяСтрока);
		
		// Дополним строку параметрами
		ИмяФункции = ИмяФункции + "(";
		
		ТекСтроки = ТекущаяСтрока.ПолучитьЭлементы();
		
		Для Каждого Параметр Из ТекСтроки Цикл
			ИмяФункции = ИмяФункции + ", " + Строка(Параметр.Значение);
		КонецЦикла;
		
		ИмяФункции = ИмяФункции + ")";
		
		ИмяФункции = СтрЗаменить(ИмяФункции, "(,", "(");
		
		Закрыть(ИмяФункции);
		
	КонецЕсли;
		
	Если ТекущаяСтрока.Тип = "ПараметрПользовательскойФункции" Тогда
		
		ПараметрыФормыКонструктора 	= Новый Структура("Документ, ВидПроформы, МассивИменРеквизитов, ДоступныеТипы, ТекущееЗначение, ТабличнаяЧасть, НеПоказыватьПользовательскиеФункции");
		ДоступныеТипы 				= ПолучитьОписаниеИзХранилища(ТекущаяСтрока.ПолучитьИдентификатор());
		
		ПараметрыФормыКонструктора.МассивИменРеквизитов 	= МассивИменРеквизитов;
		ПараметрыФормыКонструктора.ДоступныеТипы 			= ДоступныеТипы;
		ПараметрыФормыКонструктора.ТекущееЗначение 			= ТекущаяСтрока.Значение;
		ПараметрыФормыКонструктора.ТабличнаяЧасть			= ТабличнаяЧасть;
		ПараметрыФормыКонструктора.Документ					= Документ;
		ПараметрыФормыКонструктора.ВидПроформы				= ВидПроформы;
		
		ПараметрыФормыКонструктора.НеПоказыватьПользовательскиеФункции	= Ложь;
		
		ПараметрыВыполнения = Новый Структура;
		ПараметрыВыполнения.Вставить("ТекущаяСтрокаКонструктора", ТекущаяСтрока);
		Обработчик = Новый ОписаниеОповещения("ОбработкаВыбораПараметраПользовательскойФункции", ЭтотОбъект, ПараметрыВыполнения);
		РежимОткрытия = РежимОткрытияОкнаФормы.БлокироватьОкноВладельца;
		ОткрытьФорму("ОбщаяФорма.бит_ФормаКонструктораЗначенийУправляемая", ПараметрыФормыКонструктора, , , , , Обработчик, РежимОткрытия);		
				
	КонецЕсли;
	
КонецПроцедуры

// Процедура вызывается в момент выбора значения в рекурсивно-вызванной форме конструктора для значений с типом Параметры пользовательских функций.
// Выполняет заполнение выбранных значений в строках-источниках вызова.
// См. Синтакс-помощник: ОткрытьФорму().
//
&НаКлиенте
Процедура ОбработкаВыбораПараметраПользовательскойФункции(Результат, ВходящийКонтекст) Экспорт
	
	Если Результат = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТекущаяСтрока = ВходящийКонтекст.ТекущаяСтрокаКонструктора;
	ТекущаяСтрока.Значение = ?(ТипЗнч(Результат) = Тип("Структура"), Результат.Значение, Результат);
	ТекущаяСтрока.Синоним  = ТекущаяСтрока.СинонимФикс + " : <" + Строка(ТекущаяСтрока.Значение) + ">";
	
КонецПроцедуры

// Процедура вызывается в тот момент, когда пользователь выбирает значение и возвращает
// выбранное значение реквизиту-владельцу формы.
// 
&НаКлиенте
Процедура ПриВыбореЗначенияРежимПостроителя()
	
	// Проверим, какие данные содержатся в текущей строке и можно ли их выбирать.
	ДанныеСтроки = Элементы.ДеревоЗначений.ТекущиеДанные;
	
	Если ДанныеСтроки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если НадписьСтрокаЗначения = "<не используется для данного реквизита>" Тогда
		НадписьСтрокаЗначения = "";
	КонецЕсли;
	
	НадписьСтрокаЗначения_ = ПолучитьПолноеИмяРеквизита(ДанныеСтроки);
	
	Если ДанныеСтроки.Тип = "ПользовательскаяФункция" Тогда
		
		ИмяФункции = ПолучитьПолноеИмяРеквизита(ДанныеСтроки);
		
		ПодчиненныеСтроки = ДанныеСтроки.ПолучитьЭлементы();
		
		// Дополним строку параметрами
		ИмяФункции = ИмяФункции + "(";		
		Для Каждого Параметр Из ПодчиненныеСтроки Цикл
			ИмяФункции = ИмяФункции + ", " + Строка(Параметр.Значение);
		КонецЦикла;
		ИмяФункции = ИмяФункции + ")";
		
		ИмяФункции = СтрЗаменить(ИмяФункции, "(,", "(");
		
		НадписьСтрокаЗначения_ = ИмяФункции;
		
	КонецЕсли;
	
	Элементы.НадписьСтрокаЗначения.ВыделенныйТекст = НадписьСтрокаЗначения_ + " ";
	// Элементы.НадписьСтрокаЗначения.ВыделенныйТекст = " ";
	
	Поз = СтрДлина(НадписьСтрокаЗначения + " ");
	
	Элементы.НадписьСтрокаЗначения.УстановитьГраницыВыделения(Поз - 1, Поз - 1);
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиКомандФормы

&НаКлиенте
Процедура ИнфоОРежиме(Команда)
	
	ТекстВопроса = "Выбранное значение будет добавлено в поле ""Результат"". Можно использовать арифметические операции (+,-,/,*)";
	ПоказатьВопрос(, ТекстВопроса, РежимДиалогаВопрос.ОК)
	
КонецПроцедуры

&НаКлиенте
Процедура Выбрать(Команда)
	
	Если РежимПостроителяПроизвольногоВыражения Тогда
		Закрыть(НадписьСтрокаЗначения);
	Иначе	
		ПриВыбореЗначения();
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура Отмена(Команда)
	Закрыть(ТекущееЗначение);
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроцедурыИФункцииОбщегоНазначения

// Создает временное хранилище типов данных для последующей
// обработки на сервере.
// 
&НаСервере
Процедура СоздатьХранилищеТиповДанных()
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	ТаблицаЗначений.Колонки.Добавить("ИдСтроки");
	ТаблицаЗначений.Колонки.Добавить("ОграничениеТипа");
	
	ХранилищеТиповДанныхАдрес = ПоместитьВоВременноеХранилище(ТаблицаЗначений, ЭтаФорма.УникальныйИдентификатор);
	
КонецПроцедуры

// Помещает во временное хранилище очередное описание типов данных
// для новой строки дерева.
// 
&НаСервере
Процедура ПоместитьОписаниеТипаВХранилище(ИДСтроки, ОписаниеТипа)
	
	ТЗ = ПолучитьИзВременногоХранилища(ХранилищеТиповДанныхАдрес);
	
	НовСтр 					= ТЗ.Добавить();
	НовСтр.ИДСтроки 		= ИДСтроки;
	НовСтр.ОграничениеТипа 	= ОписаниеТипа;
	
	ХранилищеТиповДанныхАдрес = ПоместитьВоВременноеХранилище(ТЗ, ХранилищеТиповДанныхАдрес);
	
КонецПроцедуры

// Получает из временного хранилище ограничение типа для строки
// с идентификатором "ИДСтроки".
// 
&НаСервере
Функция ПолучитьОписаниеИзХранилища(ИДСтроки)
	
	ТЗ = ПолучитьИзВременногоХранилища(ХранилищеТиповДанныхАдрес);
	
	ИскСтр = ТЗ.Найти(ИДСтроки, "ИдСтроки");
	
	Если ИскСтр = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ИскСтр.ОграничениеТипа;
	
КонецФункции

// Обрабатывает параметры открытия формы и помещает их значения в значения
// реквизитов формы.
// 
&НаСервере
Процедура ОбработатьПараметрыОткрытияФормы()
	
	Если Параметры.Свойство("ДоступныеТипы") Тогда
		// Поместим во временное хранилище доступные типы.
		ДоступныеТипыАдрес = ПоместитьВоВременноеХранилище(Параметры.ДоступныеТипы, ЭтаФорма.УникальныйИдентификатор);
	КонецЕсли;
	
	Если Параметры.Свойство("ТабличнаяЧасть") Тогда
		ТабличнаяЧасть = Параметры.ТабличнаяЧасть;
	КонецЕсли;
	
	Если Параметры.Свойство("ТекущееЗначение") Тогда
		ТекущееЗначение = Параметры.ТекущееЗначение;
	КонецЕсли;
	
	Если Параметры.Свойство("ОписаниеТаблиц") Тогда
		ОписаниеТаблиц = Параметры.ОписаниеТаблиц;
	КонецЕсли;
	
	// Изменение кода. Начало. 05.06.2014{{
	Параметры.Свойство("ВидСравнения", ВидСравнения);
	// Изменение кода. Конец. 05.06.2014}}
	
	// Если Параметры.Свойство("ШаблонОбъект") Тогда
	// 	Параметры.ШаблонОбъект, "ШаблонОбъект";
	// КонецЕсли;
	
	Если Параметры.Свойство("Документ") Тогда
		Документ = Параметры.Документ;
	КонецЕсли;
	
	Если Параметры.Свойство("МассивИменРеквизитов") Тогда
		
		Если ТипЗнч(Параметры.МассивИменРеквизитов) = Тип("СписокЗначений") Тогда
			МассивИменРеквизитов.ЗагрузитьЗначения(Параметры.МассивИменРеквизитов.ВыгрузитьЗначения())
		Иначе	
			МассивИменРеквизитов.ЗагрузитьЗначения(Параметры.МассивИменРеквизитов.Выгрузить().ВыгрузитьКолонку("ИмяРеквизита"));
		КонецЕсли;
	
	КонецЕсли;
	
	Если Параметры.Свойство("ВидПроформы") Тогда
		ВидПроформы = Параметры.ВидПроформы;
	КонецЕсли;
	
	Параметры.Свойство("Регистр", Регистр);
	
	Если Параметры.Свойство("НеПоказыватьПользовательскиеФункции") Тогда
		НеПоказыватьПользовательскиеФункции = Параметры.НеПоказыватьПользовательскиеФункции;
	Иначе
		НеПоказыватьПользовательскиеФункции = Ложь;
	КонецЕсли;
	
	Если Параметры.Свойство("РежимПостроителя") Тогда
		
		РежимПостроителяПроизвольногоВыражения = Параметры.РежимПостроителя;
		
		Если РежимПостроителяПроизвольногоВыражения Тогда
			НадписьСтрокаЗначения = ТекущееЗначение;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Определяет, содержится ли тип "РеквизитОписаниеТипа".Типы() в описании 
// типов в реквизите формы "ДоступныеТипы".
//
&НаСервере
Функция РеквизитПрошелПоТипу(РеквизитОписаниеТипа)
	
	ДоступныеТипы = ПолучитьИзВременногоХранилища(ДоступныеТипыАдрес);
	
	// Получим массив типов реквизита
	Типы = РеквизитОписаниеТипа.Типы();// Реквизит.Тип.Типы();
	
	Если ДоступныеТипы = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Если хотя бы один тип принадлежит массиву доступных - пропустим.
	
	Для Каждого ТипРеквизита Из Типы Цикл
		Если ДоступныеТипы.СодержитТип(ТипРеквизита) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Получает ветку дерева по имени. Рекомендуется для получения веток верхнего уровня.
//
&НаСервере
Функция ПолучитьВеткуДерева(ИмяСтроки)
	
	Отбор = Новый Структура("ИмяСтроки", ИмяСтроки);
	
	МассивИД = ИменаСтрокДерева.НайтиСтроки(Отбор);
	
	Если МассивИД.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИДСтроки = МассивИД[0].ИД;
	
	Возврат ДеревоЗначений.НайтиПоИдентификатору(ИДСтроки);
	
	Возврат Неопределено;
	     
КонецФункции

// Получает ветку дерева по имени. Рекомендуется для получения веток верхнего уровня.
// 
&НаКлиенте
Функция ПолучитьВеткуДереваНаКлиенте(ИмяСтроки)
	
	Отбор = Новый Структура("ИмяСтроки", ИмяСтроки);
	
	МассивИД = ИменаСтрокДерева.НайтиСтроки(Отбор);
	
	Если МассивИД.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИДСтроки = МассивИД[0].ИД;
	
	Возврат ДеревоЗначений.НайтиПоИдентификатору(ИДСтроки);
	
	Возврат Неопределено;
	     
КонецФункции

// Возвращает теговое представление выбранного реквизита.
// 
&НаКлиенте
Функция ПолучитьПолноеИмяРеквизита(Строка, ИмяИтог = "")
	
	Если Строка.Префикс = "" Тогда                  
		ИмяИтог = ПолучитьПолноеИмяРеквизита(Строка.ПолучитьРодителя(), Строка.ИмяРеквизита + ?(СокрЛП(ИмяИтог) = "", "", ".") + ИмяИтог);
	КонецЕсли;
	
	Если Строка.Префикс <> "" Тогда
		ИмяИтог = Строка.Префикс + "." + ИмяИтог;
	КонецЕсли;
	
	Возврат ИмяИтог;
	
КонецФункции

// Разбирает теговое представление значения реквизита "СтрокаИмен" и возвращает
// массив имен строк. Сверху-вниз по старшинству.
// 
&НаКлиенте
Функция ПолучитьМассивИменСтрок(СтрокаИмен_)
	
	СтрокаИмен = СтрокаИмен_;
	
	МассивИмен = Новый Массив;
	
	Пока СтрДлина(СтрокаИмен) <> 0 Цикл
		
		// Получим текст до точки
		ПозТочки = Найти(СтрокаИмен, ".");
		
		Если ПозТочки = 0 Тогда // Это последнее имя
			МассивИмен.Добавить(СтрокаИмен);
			СтрокаИмен = "";
		Иначе
			
			ОчередноеИмя = Лев(СтрокаИмен, ПозТочки - 1);
			
			Если Найти(ОчередноеИмя, "#") > 0 Тогда // Имя тега
				
				Если ОчередноеИмя = "#Р" Тогда
					ОчередноеИмя = "Реквизиты";	
				ИначеЕсли ОчередноеИмя = "#П" Тогда
					ОчередноеИмя = "ПользовательскиеФункции";
				// Изменение кода. Начало. 22.07.2016{{
				ИначеЕсли ОчередноеИмя = "#Ф" Тогда
					ОчередноеИмя = "ПрочиеФункции";
				// Изменение кода. Конец. 22.07.2016}}
				ИначеЕсли ОчередноеИмя = "#Д" Тогда
					ОчередноеИмя = "ДопРеквизиты";
				ИначеЕсли ОчередноеИмя = "#А" Тогда
					ОчередноеИмя = "ДопАналитика";	
				ИначеЕсли ОчередноеИмя = "#Т" Тогда
					МассивИмен.Добавить("Реквизиты");
					ОчередноеИмя = ТабличнаяЧасть;
				КонецЕсли;
				
				МассивИмен.Добавить(ОчередноеИмя);
				
				Если ОчередноеИмя = "ПользовательскиеФункции" ИЛИ ОчередноеИмя = "ПрочиеФункции" Тогда
					// Сократим строку имен
					СтрокаИмен = Прав(СтрокаИмен, СтрДлина(СтрокаИмен) - ПозТочки);
					// Получим имя самой функции: оно до скобок. Если нет скобок - не позиционируем.
					Скобка = Найти(СтрокаИмен, "(");
					Если Скобка = 0 Тогда
						
					Иначе
						ОчередноеИмя = Лев(СтрокаИмен, Скобка - 1);
						МассивИмен.Добавить(ОчередноеИмя);
					КонецЕсли;
					Возврат МассивИмен;
				КонецЕсли;
				
			Иначе
				МассивИмен.Добавить(ОчередноеИмя);
			КонецЕсли;
			
			// Сократим строку имен
			СтрокаИмен = Прав(СтрокаИмен, СтрДлина(СтрокаИмен) - ПозТочки);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МассивИмен;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляУправленияВнешнимВидомФормы

// Заполняет дерево значений предопределенными строками (строками верхнего уровня).
// 
&НаСервере
Процедура ЗаполнитьДеревоПредопределенными()
	
	СтрокиДЗ = ДеревоЗначений.ПолучитьЭлементы();
	
	ДобавитьВеткуДерева(СтрокиДЗ, "Реквизиты", "Реквизиты документа", "Реквизиты", "#Р", Ложь);
	ДобавитьВеткуДерева(СтрокиДЗ, "ДопРеквизиты", "Доп. реквизиты", "ДопРеквизиты", "#Д", Ложь);
	
	// AKuznetsov - начало изменения 25.08.11
	ДобавитьВеткуДерева(СтрокиДЗ, "ДопАналитика", "Доп. аналитика", "ДопАналитика", "#А", Ложь);
	// AKuznetsov - конец изменения
	
	ДобавитьВеткуДерева(СтрокиДЗ, "ПроизвольныеТаблицы", "Произвольные таблицы", "ПроизвольныеТаблицы", "#Т", Ложь);
	
	Если не НеПоказыватьПользовательскиеФункции Тогда
		ДобавитьВеткуДерева(СтрокиДЗ, "Функции", "Пользовательские функции", "ПользовательскиеФункции", "#П", Ложь);
	КонецЕсли;
	
	// Изменение кода. Начало. 20.07.2016{{
	Если ДобавитьВеткуПрочиеФункции(Регистр.ИмяРегистра) Тогда
		
		ДобавитьВеткуДерева(СтрокиДЗ, "ПрочиеФункции", "Прочие функции", "ПрочиеФункции", "#Ф", Ложь);
		
	КонецЕсли; 
	// Изменение кода. Конец. 20.07.2016}}
	
	ДобавитьВеткуДерева(СтрокиДЗ, "ФиксированноеЗначение", "Фиксированное значение", "ФиксированноеЗначение", "-", Ложь);
	
	ДобавитьВеткуДерева(СтрокиДЗ, "ПроизвольнаяСтрока", "Произвольная строка", "ПроизвольнаяСтрока", "?", Ложь);
	
КонецПроцедуры

// Добавляет новую ветку в дерево значений.
// 
&НаСервере
Функция ДобавитьВеткуДерева(Родитель, Имя, Синоним, Тип, Префикс = "", Использование = Истина)
	
	НоваяСтрока 				= Родитель.Добавить();
	НоваяСтрока.ИмяРеквизита 	= Имя;
	НоваяСтрока.Синоним		 	= Синоним;
	НоваяСтрока.СинонимФикс	 	= Синоним;
	НоваяСтрока.Тип			 	= Тип;
	НоваяСтрока.Префикс			= Префикс;
	НоваяСтрока.Использование	= Использование;
	
	Картинка = 3;
	
	Если Тип = "Реквизиты" Тогда
		Картинка = 0;	
	ИначеЕсли Тип = "ДопРеквизиты" Тогда
		Картинка = 1;
	ИначеЕсли Тип = "ПользовательскиеФункции" ИЛИ Тип = "ПрочиеФункции" Тогда
		Картинка = 2;
	ИначеЕсли Тип = "Реквизит" Тогда
		Картинка = 3;
	ИначеЕсли Тип = "ТабличнаяЧасть" или Тип = "ТабличнаяЧастьВрем" Тогда
		Картинка = 4;
	ИначеЕсли Тип = "ПроизвольныеТаблицы" Тогда
		Картинка = 7;	
	ИначеЕсли Тип = "ФиксированноеЗначение" Тогда
		Картинка = 5;	
	ИначеЕсли Тип = "ПараметрПользовательскойФункции" Тогда
		Картинка = 6;
		НоваяСтрока.Синоним = НоваяСтрока.СинонимФикс + " : <" + Строка(НоваяСтрока.Значение) + ">";
	КонецЕсли;
	
	НоваяСтрока.ИндексКартинки = Картинка;
	
	НовСтрокаИД = ИменаСтрокДерева.Добавить();
	
	НовСтрокаИД.ИД 			= НоваяСтрока.ПолучитьИдентификатор();
	НовСтрокаИД.ИмяСтроки 	= Имя;
	
	Возврат НоваяСтрока;
	
КонецФункции

// Заполняет дерево значений в соответствии с данными шаблона, 
// содержащегося в реквизите формы "ШаблонОбъект".
// 
&НаСервере
 Процедура ЗаполнитьДеревоПоТекущемуШаблону()
	
	Если Не ЗначениеЗаполнено(Документ) Тогда
		Возврат;	
	КонецЕсли;
	
	ТипОбъекта = Документ.ТипЗначенияОбъекта.Получить();
	
	Проформа = Ложь;
	
	Если ТипОбъекта = Тип("ДокументСсылка.бит_Проформы") и ЗначениеЗаполнено(ВидПроформы) Тогда
		Проформа = Истина;
		ЭлементКоллекции = Справочники.бит_ВидыПроформ.ЭмулироватьМетаданные(ВидПроформы, "Массив");
	Иначе	
		// Определим элемент коллекции метаданных, соответствующий выбранному документу.
		ЭлементКоллекции = Документы[Документ.ИмяОбъекта].ПустаяСсылка().Метаданные();
	КонецЕсли;

	ОписаниеТипаДата = Новый ОписаниеТипов("Дата");
						 
	// Заполним дату
	Если РеквизитПрошелПоТипу(ОписаниеТипаДата) Тогда
		НоваяВетка = ДобавитьВеткуДерева(ПолучитьВеткуДерева("Реквизиты").ПолучитьЭлементы(), "Дата", "Дата", "Реквизит",, Истина);
		ПоместитьОписаниеТипаВХранилище(НоваяВетка.ПолучитьИдентификатор(), ОписаниеТипаДата);
		// НоваяВетка.ОграничениеТипа = ОписаниеТипаДата;
	КонецЕсли;
	
	// Заполним реквизиты.
	Для Каждого Реквизит Из ЭлементКоллекции.Реквизиты Цикл
		ДобавитьРеквизит(ПолучитьВеткуДерева("Реквизиты"), Реквизит, 4);
	КонецЦикла;
	
	Если Проформа Тогда
		
		Для Каждого Реквизит Из ЭлементКоллекции.СтандартныеРеквизиты Цикл
			ДобавитьРеквизит(ПолучитьВеткуДерева("Реквизиты"), Реквизит, 4);
		КонецЦикла
		
	КонецЕсли;
	
	// Заполним табличные части и их реквизиты.
	Если СокрЛП(ТабличнаяЧасть) <> "" Тогда
		
		// Определим, табличная часть ли это.
		ЭтоТабЧасть = Найти(ТабличнаяЧасть, "$") = 0 и Найти(ТабличнаяЧасть, "()") = 0;
		
		Если ЭтоТабЧасть Тогда
			
			Для Каждого ТабЧасть_ Из ЭлементКоллекции.ТабличныеЧасти Цикл
				
				Если Проформа Тогда
					ТабЧасть = ТабЧасть_.Значение;
				Иначе
					ТабЧасть = ТабЧасть_;
				КонецЕсли;
				
				Если не ТабЧасть.Имя = ТабличнаяЧасть Тогда
					Продолжить;
				КонецЕсли;
				
				ВеткаТабЧасть = ДобавитьВеткуДерева(ПолучитьВеткуДерева("Реквизиты").ПолучитьЭлементы(), ТабЧасть.Имя, ТабЧасть.Синоним, "ТабличнаяЧасть", "#Т", Ложь);
				
				Для Каждого Реквизит Из ТабЧасть.Реквизиты Цикл
					ДобавитьРеквизит(ВеткаТабЧасть, Реквизит, 4);
				КонецЦикла;
				
			КонецЦикла;
			
		Иначе
			
			// Это описание произвольной таблицы.
			// Найдем таблицу по имени.
			
			Если ТипЗнч(ОписаниеТаблиц) = Тип("Структура") Тогда
				
				МассивТЧ = ОписаниеТаблиц.МассивОписанияТаблиц;
				
				Для Каждого Таблица Из МассивТЧ Цикл
					
					ИмяТаблицы = Таблица.Имя;
					
					Если ИмяТаблицы <> ТабличнаяЧасть Тогда
						Продолжить;
					КонецЕсли;
					
					ВеткаТабЧасть = ДобавитьВеткуДерева(ПолучитьВеткуДерева("ПроизвольныеТаблицы").ПолучитьЭлементы(), ИмяТаблицы, ИмяТаблицы, "ТабличнаяЧастьВрем", "#Т", Ложь);
					
					Для Каждого Реквизит Из Таблица.Реквизиты Цикл
						ДобавитьРеквизит(ВеткаТабЧасть, Реквизит, 4);
					КонецЦикла;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Заполним дополнительные реквизиты.
	// МассивИменРеквизитов = ШаблонОбъект.ДополнительныеРеквизиты.ВыгрузитьКолонку("ИмяРеквизита");
	
	Для Каждого ИмяРеквизита Из МассивИменРеквизитов Цикл
		ВеткаТабЧасть = ДобавитьВеткуДерева(ПолучитьВеткуДерева("ДопРеквизиты").ПолучитьЭлементы(), ИмяРеквизита.Значение, ИмяРеквизита.Значение + "()", "ДопРеквизит", "", Истина);
	КонецЦикла;
	
	// AKuznetsov - начало изменения 25.08.11
	// Запрос = Новый Запрос("ВЫБРАТЬ
	// |	НазначениеДополнительныхАналитик.Аналитика
	// |ИЗ
	// |	РегистрСведений.бит_НазначениеДополнительныхАналитик КАК НазначениеДополнительныхАналитик
	// |ГДЕ
	// |	(НазначениеДополнительныхАналитик.Объект = &Объект
	// |			ИЛИ НазначениеДополнительныхАналитик.Объект = ЗНАЧЕНИЕ(Справочник.бит_ОбъектыСистемы.ПустаяСсылка))");
	// Запрос.УстановитьПараметр("Объект", Документ);
	
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	бит_ВидыДополнительныхАналитик.Ссылка КАК Аналитика
	|ИЗ
	|	ПланВидовХарактеристик.бит_ВидыДополнительныхАналитик КАК бит_ВидыДополнительныхАналитик");
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если НЕ РеквизитПрошелПоТипу(Выборка.Аналитика.ТипЗначения) Тогда
			Продолжить;
		КонецЕсли;
		Если Выборка.Аналитика.Предопределенный Тогда
			ИмяРеквизита = ПланыВидовХарактеристик.бит_ВидыДополнительныхАналитик.ПолучитьИмяПредопределенного(Выборка.Аналитика);
		Иначе
			ИмяРеквизита = "Ид_" + СокрЛП(Выборка.Аналитика.Код);
		КонецЕсли;
		
		ВеткаТабЧасть = ДобавитьВеткуДерева(ПолучитьВеткуДерева("ДопАналитика").ПолучитьЭлементы(),
		ИмяРеквизита,
		СокрЛП(Выборка.Аналитика),
		"ДопАналитика",
		"",
		Истина);
	КонецЦикла;
	// AKuznetsov - конец изменения
	
	Если не НеПоказыватьПользовательскиеФункции Тогда
	
		// Заполним пользовательские функции.
		ВыборкаФункций = Справочники.бит_ПользовательскиеФункции.Выбрать();
		
		Пока ВыборкаФункций.Следующий() Цикл
			ДобавитьПользовательскуюФункцию(ПолучитьВеткуДерева("Функции").ПолучитьЭлементы(), ВыборкаФункций.Ссылка);
		КонецЦикла;
		
	КонецЕсли;
	
	// Изменение кода. Начало. 20.07.2016{{
	Если ДобавитьВеткуПрочиеФункции(Регистр.ИмяРегистра) Тогда
		
		ВеткаПрочиеФункции = ПолучитьВеткуДерева("ПрочиеФункции").ПолучитьЭлементы();
		ДобавитьФункцииМодуля(ВеткаПрочиеФункции);
		
	КонецЕсли; 
	// Изменение кода. Конец. 20.07.2016}}
	
КонецПроцедуры

// Процедура заполняет ветку "ПрочиеФункции" функциями, которые доступны в общем модуле бит_мхо_ОбщегоНазначенияСервер. 
//
&НаСервере
Процедура ДобавитьФункцииМодуля(ВеткаПрочиеФункции)

	МассивОписаний = Новый Массив;
	
	
	ОписаниеФункции = Новый Структура("Имя, Параметры","ПересчитатьРеглУпр",Новый Структура("Сумма, Период, СтруктураШапкиДокумента","Число","Дата",Неопределено));
	МассивОписаний.Добавить(ОписаниеФункции);
	ОписаниеФункции = Новый Структура("Имя, Параметры","ПересчитатьРеглМУ",Новый Структура("Сумма, Период, СтруктураШапкиДокумента","Число","Дата",Неопределено));
	МассивОписаний.Добавить(ОписаниеФункции);
	ОписаниеФункции = Новый Структура("Имя, Параметры","ПересчитатьРеглСценарий",Новый Структура("Сумма, Период, Сценарий, СтруктураШапкиДокумента","Число","Дата","СправочникСсылка.СценарииПланирования",Неопределено));
	МассивОписаний.Добавить(ОписаниеФункции);
	ОписаниеФункции = Новый Структура("Имя, Параметры","ПересчитатьПоВалюте",Новый Структура("Сумма, Период, ВалютаНач, ВалютаКон","Число","Дата","СправочникСсылка.Валюты","СправочникСсылка.Валюты"));
	МассивОписаний.Добавить(ОписаниеФункции);

	Для каждого ТекОписание Из МассивОписаний Цикл
		
		СтрокиФункции = ДобавитьВеткуДерева(ВеткаПрочиеФункции, ТекОписание.Имя, ТекОписание.Имя+"()", "ПользовательскаяФункция", "", Истина).ПолучитьЭлементы();
		
		Для каждого КиЗ Из ТекОписание.Параметры Цикл
		
			   ИмяПараметра = КиЗ.Ключ;
			   ТипСтр = КиЗ.Значение;
			   
			   Если ЗначениеЗаполнено(ТипСтр) Тогда
				   
				   Строка = ДобавитьВеткуДерева(СтрокиФункции, ИмяПараметра, ИмяПараметра, "ПараметрПользовательскойФункции", "", Ложь);
				   ПоместитьОписаниеТипаВХранилище(Строка.ПолучитьИдентификатор(), Новый ОписаниеТипов(ТипСтр));
				   
			   Иначе	
				   
				   // Не редактируемый параметр, в функцию жестко подставляется имя.
				   Строка = ДобавитьВеткуДерева(СтрокиФункции, ИмяПараметра, ИмяПараметра, "", "", Ложь);
				   Строка.Значение = ИмяПараметра;
				   
			   КонецЕсли; 
		
		КонецЦикла; 
		
	КонецЦикла; 

КонецПроцедуры // ДобавитьФункцииМодуля()

// Рекурсивно добавляет в дерево значений описание всех реквизитов, подчиненных
// "РеквизитМетаданные" с глубиной иерархии "НеобходимыйУровень".
//
&НаСервере
Функция ДобавитьРеквизит(ВеткаДерева, РеквизитМетаданные, НеобходимыйУровень)
	
	МетаданныеСсылки = бит_МеханизмХозяйственныхОперацийСервер.ПолучитьМетаданныеСсылкиПоТипу(РеквизитМетаданные.Тип);
	
	Если МетаданныеСсылки = Неопределено или НеобходимыйУровень = 0 Тогда
		Если РеквизитПрошелПоТипу(РеквизитМетаданные.Тип) Тогда 
			ВеткаДереваНов = ДобавитьВеткуДерева(ВеткаДерева.ПолучитьЭлементы(), РеквизитМетаданные.Имя, РеквизитМетаданные.Синоним, "Реквизит");
			ПоместитьОписаниеТипаВХранилище(ВеткаДереваНов.ПолучитьИдентификатор(), РеквизитМетаданные.Тип);
// ВеткаДереваНов.ОграничениеТипа = РеквизитМетаданные.Тип;
			Возврат ВеткаДереваНов;
		КонецЕсли;
	Иначе
		
		ВеткаДереваНов = ДобавитьВеткуДерева(ВеткаДерева.ПолучитьЭлементы(), РеквизитМетаданные.Имя, РеквизитМетаданные.Синоним, "Реквизит");
		ПоместитьОписаниеТипаВХранилище(ВеткаДереваНов.ПолучитьИдентификатор(), РеквизитМетаданные.Тип);
		// ВеткаДереваНов.ОграничениеТипа = РеквизитМетаданные.Тип;
		
		Для Каждого Реквизит Из МетаданныеСсылки.Реквизиты Цикл
			ДобавитьРеквизит(ВеткаДереваНов, Реквизит, НеобходимыйУровень - 1)
		КонецЦикла;
		
		Если не РеквизитПрошелПоТипу(РеквизитМетаданные.Тип) Тогда
			Если ВеткаДереваНов.Строки.Количество() = 0 Тогда
				УдалитьВеткуДерева(ВеткаДереваНов);
			Иначе
				ВеткаДереваНов.Использование = Ложь;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

// Удаляет из дерева значений ветку "Ветка".
//
&НаСервере
Процедура УдалитьВеткуДерева(Ветка)
	Родитель = Ветка.ПолучитьРодителя();
	Родитель.ПолучитьЭлементы().Удалить(Ветка.ПолучитьИдентификатор);
КонецПроцедуры

// Добавляет в дерево значений для выбора пользовательскую функцию
// с описанием параметров ее вызова.
//
&НаСервере
Процедура ДобавитьПользовательскуюФункцию(СтрокиДерева, ФункцияСсылка)
	
	// Добавим строку для самой функции
	СтрокиФункции = ДобавитьВеткуДерева(СтрокиДерева, ФункцияСсылка.Наименование, ФункцияСсылка.Наименование + "()", "ПользовательскаяФункция", "", Истина).ПолучитьЭлементы();
	
	// Добавим строки для параметров функции
	Для Каждого Параметр Из ФункцияСсылка.ПараметрыФункции Цикл
		Строка = ДобавитьВеткуДерева(СтрокиФункции, Параметр.Наименование, Параметр.Наименование, "ПараметрПользовательскойФункции", "", Ложь);
		ПоместитьОписаниеТипаВХранилище(Строка.ПолучитьИдентификатор(), Параметр.ТипПараметра.Получить());
		// Строка.ОграничениеТипа = Параметр.ТипПараметра.Получить();
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает текущую строку в соответствии со значением реквизита формы "ТекущееЗначений".
// 
&НаКлиенте
Процедура ПозиционироватьВыделение()
	
	Если ТипЗнч(ТекущееЗначение) = Тип("Строка") Тогда
		
		// Проверим, может быть это режим построителя.
		Если СтрЧислоВхождений(ТекущееЗначение, "#") > 1 
			или Найти(ТекущееЗначение, "+")
			или Найти(ТекущееЗначение, "-")
			или Найти(ТекущееЗначение, "*")
			или Найти(ТекущееЗначение, "/") Тогда
			
			// Это произвольное выражение.
			РежимПостроителяПроизвольногоВыражения = Истина;
			
			Элементы.ДеревоЗначений.ТекущаяСтрока = 0;
			
		КонецЕсли;
		
		Если Найти(ТекущееЗначение, "#") > 0 Тогда // Это тег
			
			// Начнем обход по именам строк с начала тега
			// 1. Получим массив имен строк.
			МассивИмен = ПолучитьМассивИменСтрок(ТекущееЗначение);
			
			ПозиционироватьВыделениеПоМассивуИмен(МассивИмен);
			
			Если МассивИмен[0] = "ПользовательскиеФункции" Тогда
				// Заполнить значения параметров.
				ЗаполнитьПараметрыСтрокиФункции(ДеревоЗначений.НайтиПоИдентификатору(Элементы.ДеревоЗначений.ТекущаяСтрока), ТекущееЗначение);
			КонецЕсли;
			
		Иначе // Фиксированное значение типа "Строка".
			ПолеФиксированноеЗначение = ТекущееЗначение;
			Элементы.ДеревоЗначений.ТекущаяСтрока = ПолучитьВеткуДереваНаКлиенте("ФиксированноеЗначение").ПолучитьИдентификатор();
		КонецЕсли;
		
	Иначе // Это фиксированное значение.
		ПолеФиксированноеЗначение = ТекущееЗначение;
		Элементы.ДеревоЗначений.ТекущаяСтрока = ПолучитьВеткуДереваНаКлиенте("ФиксированноеЗначение").ПолучитьИдентификатор();
	КонецЕсли;
	
	Если РежимПостроителяПроизвольногоВыражения Тогда
		НадписьСтрокаЗначения = ТекущееЗначение;
	КонецЕсли;
	
КонецПроцедуры

// Находит строку в дереве значений, согласно старшинству в "МассивИмен"
// и устанавливает ее текущей.
// 
&НаКлиенте
Процедура ПозиционироватьВыделениеПоМассивуИмен(МассивИмен)
	
	ТекущийРодитель = ДеревоЗначений;
	
	Для Каждого Элемент Из МассивИмен Цикл
		
		ДляПоиска = Элемент;
		
		Если ДляПоиска = "ПользовательскиеФункции" Тогда
			ДляПоиска = "Функции";
		КонецЕсли;
		
		ТекущийРодитель = ПолучитьВеткуДереваНаКлиенте(ДляПоиска);
		
		Если ТекущийРодитель = Неопределено Тогда
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
	Элементы.ДеревоЗначений.ТекущаяСтрока = ТекущийРодитель.ПолучитьИдентификатор();
	
КонецПроцедуры

// Выделяет из строки описания параметры вызова функции и заполняет их.
// 
&НаКлиенте
Процедура ЗаполнитьПараметрыСтрокиФункции(СтрокаФункции, СтрокаИмя)
	
	// Получим массив параметров
	Массив = Новый Массив;
	// Выделим подстроку между скобок
	СкобкаОткр = Найти(СтрокаИмя, "(");
	СкобкаЗакр = Найти(СтрокаИмя, ")");
	ПодстрокаПоиска = Сред(СтрокаИмя, СкобкаОткр + 1, СкобкаЗакр - СкобкаОткр - 1);
	
	Пока СтрДлина(ПодстрокаПоиска) <> 0 Цикл
		// Получим текст до запятой
		ПозТочки = Найти(ПодстрокаПоиска, ", ");
		
		Если ПозТочки = 0 Тогда // Это последнее имя
			Массив.Добавить(СокрЛП(ПодстрокаПоиска));
			ПодстрокаПоиска = "";
		Иначе
			ОчередноеИмя = Лев(ПодстрокаПоиска, ПозТочки - 1);
			Массив.Добавить(СокрЛП(ОчередноеИмя));
			// Сократим строку имен
			ПодстрокаПоиска = Прав(ПодстрокаПоиска, СтрДлина(ПодстрокаПоиска) - ПозТочки);
		КонецЕсли;
	КонецЦикла;
	
	// Заполним значения параметров
	жи = -1;
	
	СтрокиФункции = СтрокаФункции.ПолучитьЭлементы();
	
	Для Каждого Строка Из СтрокиФункции Цикл
		жи = жи + 1;
		Строка.Значение = Массив[жи];
		Строка.Синоним = Строка.СинонимФикс + " : <" + Строка(Строка.Значение) + ">";
	КонецЦикла;
	
КонецПроцедуры

// Функция добавляет ветку прочие функции.
//
// Возвращаемое значение:
//  флДобавить - Булево.
//
&НаКлиентеНаСервереБезКонтекста
Функция ДобавитьВеткуПрочиеФункции(ИмяРегистра)

    Имена = Новый Соответствие;
	Имена.Вставить("бит_ОборотыПоБюджетам", Истина);
	Для Н = 1 По 5 Цикл
		
		Имена.Вставить("бит_Дополнительный_"+Н, Истина);
		
	КонецЦикла; 

	флДобавить = ?(Имена[ИмяРегистра] = Истина, Истина, Ложь);
	
	Возврат флДобавить;
	
КонецФункции // ДобавитьВеткуПроизвольныеФункции()

#КонецОбласти

#КонецОбласти
